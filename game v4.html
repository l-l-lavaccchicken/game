<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Global History & Cyber Security Study Portal</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Global Educational Website Style */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }

        /* --- Educational Dashboard Styles --- */
        .dashboard-card {
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1);
        }

        .tab-button {
            transition: all 0.2s;
            border-bottom: 3px solid transparent;
        }

        .tab-button.active {
            border-bottom: 3px solid #3b82f6; /* Blue-500 */
            color: #1d4ed8; /* Blue-700 */
            font-weight: 600;
        }

        /* --- Calculator Styles --- */
        .calculator {
            max-width: 300px;
            margin: 0 auto;
            background-color: #1f2937; /* Dark gray */
            padding: 1rem;
            border-radius: 0.5rem;
        }

        .calc-display {
            background-color: #f3f4f6;
            color: #1f2937;
            padding: 0.75rem;
            text-align: right;
            font-size: 1.5rem;
            margin-bottom: 0.75rem;
            border-radius: 0.25rem;
            font-family: monospace;
            min-height: 3rem;
        }

        .calc-button {
            @apply p-4 rounded-lg text-lg font-bold transition duration-150 shadow-md;
        }

        .calc-number {
            @apply bg-gray-600 text-white hover:bg-gray-700 active:bg-gray-800;
        }

        .calc-operator {
            @apply bg-orange-500 text-white hover:bg-orange-600 active:bg-orange-700;
        }

        .calc-utility {
            @apply bg-gray-400 text-gray-800 hover:bg-gray-500 active:bg-gray-600;
        }


        /* --- Game-Specific Styles (Only apply when game is visible) --- */
        #gameContainer {
            background-color: #1e1e2e; /* Dark, retro background */
            font-family: 'Press Start 2P', monospace;
            max-width: 840px; /* Max width for centering */
        }

        /* Essential for true pixel scaling in modern browsers */
        #gameCanvas {
            image-rendering: optimizeSpeed; 
            image-rendering: -moz-crisp-edges; 
            image-rendering: -webkit-optimize-contrast; 
            image-rendering: crisp-edges;
            image-rendering: pixelated;
            border: 4px solid #f0f0f0; 
            box-shadow: 0 0 0 8px #444455; 
            background-color: #334; 
            width: 100%; 
            max-width: 800px; 
            height: auto;
            aspect-ratio: 512 / 400; 
            outline: none; /* Remove focus outline for game feel */
        }

        .game-ui-text {
            color: #f0f0f0;
            text-shadow: 2px 2px #000;
        }

        .modal {
            background: rgba(0, 0, 0, 0.9);
        }

        .modal-content {
            background: #222233;
            border: 4px solid #ffcc00;
            box-shadow: 0 0 10px #ffcc00;
        }
        
        .snes-button {
            padding: 12px 20px;
            font-size: 0.75rem; 
            text-shadow: 1px 1px #000;
            color: #f0f0f0;
            background-color: #444455;
            border: 3px solid #666677;
            border-bottom-width: 6px;
            transition: all 0.1s ease;
            box-shadow: 0 4px #222233;
            text-transform: uppercase;
            font-family: 'Press Start 2P', monospace;
        }

        .snes-button:hover {
            background-color: #555566;
        }

        .snes-button:active {
            border-bottom-width: 3px;
            transform: translateY(3px);
            box-shadow: 0 1px #222233;
        }

        .player-cyan { color: #00ffff; }
        .player-magenta { color: #ff00ff; }

        .ttt-cell {
            border: 2px solid #ffcc00;
        }
    </style>
</head>
<body>

    <div id="appContainer" class="w-full max-w-5xl">
        
        <!-- 1. EDUCATIONAL COVER CONTENT (Default View) -->
        <div id="educationalContent" class="dashboard-card p-4 md:p-8 transition-opacity duration-500">
            <header class="border-b-4 border-blue-500 pb-4 mb-6">
                <h1 class="text-3xl md:text-4xl font-extrabold text-gray-800">
                    <span class="text-blue-600">Secure Study</span> & <span class="text-purple-600">Research Hub</span>
                </h1>
                <p class="text-md text-gray-500 mt-2">Certified Learning Module 3.1: Modern Threats and Resilience</p>
            </header>
            
            <!-- Tab Navigation -->
            <div class="flex flex-wrap border-b border-gray-200 mb-6">
                <button class="tab-button active py-2 px-4 text-gray-600" data-tab="history">Global History</button>
                <button class="tab-button py-2 px-4 text-gray-600" data-tab="cyber">Cyber Security</button>
                <button class="tab-button py-2 px-4 text-gray-600" data-tab="math">Math & Calculator</button>
                <button class="tab-button py-2 px-4 text-gray-600" data-tab="science">Physical Science</button>
            </div>

            <!-- Tab Content Containers -->
            <div id="tabContent">
                
                <!-- History Tab -->
                <div id="history" class="tab-pane">
                    <div class="grid md:grid-cols-2 gap-8">
                        <div class="bg-blue-50 p-6 rounded-lg shadow-inner">
                            <h2 class="text-2xl font-semibold mb-3 text-blue-700">Ancient Resilience Studies</h2>
                            <p class="text-gray-700">
                                Examining the defensive structures of the Great Wall of China and comparing them to modern perimeter firewall architectures. Analyze the impact of the Byzantine-Sassanid War on current Eurasian supply chain stability.
                            </p>
                            <ul class="list-disc list-inside space-y-2 text-gray-700 mt-4">
                                <li>The Roman Empire and Digital Decentralization (Required Reading)</li>
                                <li>Case Study: Fall of Constantinople (Lesson 4.2)</li>
                            </ul>
                        </div>
                        <div class="bg-blue-50 p-6 rounded-lg shadow-inner">
                            <h2 class="text-2xl font-semibold mb-3 text-blue-700">Review & Quick Links</h2>
                            <button class="w-full mt-4 bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition duration-150">
                                Take History Quiz
                            </button>
                            <p class="text-sm text-gray-500 mt-3">
                                **NOTE:** Review key dates from Module 3.1 before proceeding.
                            </p>
                        </div>
                    </div>
                </div>

                <!-- Cyber Security Tab -->
                <div id="cyber" class="tab-pane hidden">
                    <div class="grid md:grid-cols-2 gap-8">
                        <div class="bg-red-50 p-6 rounded-lg shadow-inner">
                            <h2 class="text-2xl font-semibold mb-3 text-red-700">Q3 Policy Update: MFA & Zero Trust</h2>
                            <p class="text-gray-700">
                                Mandatory Multi-Factor Authentication (MFA) is now enforced network-wide. All access must adhere to the Zero Trust architecture: never trust, always verify.
                            </p>
                            <ul class="list-disc list-inside space-y-2 text-gray-700 mt-4">
                                <li>Phishing Simulation Results (Module 1 Review)</li>
                                <li>Report on Common Malware Signatures (Lesson 5.1)</li>
                            </ul>
                        </div>
                        <div class="bg-red-50 p-6 rounded-lg shadow-inner">
                            <h2 class="text-2xl font-semibold mb-3 text-red-700">Mandatory Action</h2>
                            <button class="w-full mt-4 bg-red-600 text-white px-4 py-2 rounded-lg hover:bg-red-700 transition duration-150">
                                Complete Security Acknowledgment
                            </button>
                            <p class="text-sm text-gray-500 mt-3">
                                Failure to complete the security quiz by EOD will result in reduced access privileges.
                            </p>
                        </div>
                    </div>
                </div>

                <!-- Math & Calculator Tab -->
                <div id="math" class="tab-pane hidden">
                    <div class="grid md:grid-cols-2 gap-8 items-start">
                        <!-- Math Content -->
                        <div class="bg-green-50 p-6 rounded-lg shadow-inner">
                            <h2 class="text-2xl font-semibold mb-3 text-green-700">Calculus & Cryptography</h2>
                            <p class="text-gray-700">
                                Reviewing differential equations for predictive modelling in threat detection. Understanding modulo arithmetic is crucial for RSA and other public-key cryptography algorithms.
                            </p>
                            <p class="text-lg font-mono text-green-800 mt-4">
                                $E(k) = C \cdot M^e \pmod{n}$
                            </p>
                            <p class="text-sm text-gray-500 mt-3">
                                Tip: Use the calculator on the right for quick checks on large modulo operations.
                            </p>
                        </div>
                        
                        <!-- Calculator -->
                        <div class="calculator">
                            <div id="calcDisplay" class="calc-display">0</div>
                            <div class="grid grid-cols-4 gap-2">
                                <button class="calc-utility col-span-2" data-action="clear">AC</button>
                                <button class="calc-utility" data-action="negate">+/-</button>
                                <button class="calc-operator" data-action="/">/</button>

                                <button class="calc-number" data-value="7">7</button>
                                <button class="calc-number" data-value="8">8</button>
                                <button class="calc-number" data-value="9">9</button>
                                <button class="calc-operator" data-action="*">×</button>

                                <button class="calc-number" data-value="4">4</button>
                                <button class="calc-number" data-value="5">5</button>
                                <button class="calc-number" data-value="6">6</button>
                                <button class="calc-operator" data-action="-">−</button>

                                <button class="calc-number" data-value="1">1</button>
                                <button class="calc-number" data-value="2">2</button>
                                <button class="calc-number" data-value="3">3</button>
                                <button class="calc-operator" data-action="+">+</button>

                                <button class="calc-number col-span-2" data-value="0">0</button>
                                <button class="calc-number" data-value=".">.</button>
                                <button class="calc-operator" data-action="=">=</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Science Tab -->
                <div id="science" class="tab-pane hidden">
                    <div class="grid md:grid-cols-2 gap-8">
                        <div class="bg-yellow-50 p-6 rounded-lg shadow-inner">
                            <h2 class="text-2xl font-semibold mb-3 text-yellow-700">Quantum States & Network Latency</h2>
                            <p class="text-gray-700">
                                Exploring the relationship between quantum entanglement theory and ultra-low latency network performance. The principles of superposition can be applied to simultaneous data checks in redundant systems.
                            </p>
                            <p class="text-lg font-mono text-yellow-800 mt-4">
                                $$E = mc^2$$
                            </p>
                        </div>
                        <div class="bg-yellow-50 p-6 rounded-lg shadow-inner">
                            <h2 class="text-2xl font-semibold mb-3 text-yellow-700">Lab Reports</h2>
                            <ul class="list-disc list-inside space-y-2 text-gray-700">
                                <li>Lab 1: Measuring the Speed of Light (via optical fiber)</li>
                                <li>Lab 2: Chemical Composition of Modern Server Coolants</li>
                            </ul>
                            <button class="w-full mt-4 bg-yellow-600 text-white px-4 py-2 rounded-lg hover:bg-yellow-700 transition duration-150">
                                View Experiment Data
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <footer class="mt-10 pt-4 border-t border-gray-300 text-center text-sm text-gray-500">
                <p>&copy; 2025 Secure Learning Initiatives. All rights reserved. Do not attempt unauthorized access.</p>
                <p class="mt-2 text-xs">Access Code Protocol Active: [8-Key Sequence Required] - Use Arrow Keys!</p>
            </footer>
        </div>
        
        <!-- 2. HIDDEN GAME CONTAINER -->
        <div id="gameContainer" class="hidden flex-col items-center w-full max-w-4xl p-2 sm:p-4 rounded-xl shadow-2xl">
            
            <!-- UI Display Bar -->
            <div id="uiContainer" class="flex flex-col w-full max-w-[800px] p-2 text-xs sm:text-sm game-ui-text">
                <div class="flex justify-between">
                    <span id="score1Display" class="player-cyan">P1 SCORE: 00000</span>
                    <span id="waveDisplay" class="text-yellow-400">WAVE 0 / ZOMBIES: 0</span>
                    <span id="health1Display" class="player-cyan">P1 HEALTH: 100</span>
                </div>
                <div id="p2UiGroup" class="flex justify-between mt-1 hidden">
                    <span id="score2Display" class="player-magenta">P2 SCORE: N/A</span>
                    <span id="spacer"></span>
                    <span id="health2Display" class="player-magenta">P2 HEALTH: N/A</span>
                </div>
            </div>
            
            <div id="weaponDisplay" class="w-full max-w-[800px] p-2 text-xs sm:text-sm game-ui-text text-center">
                WEAPON: Shotgun
            </div>


            <canvas id="gameCanvas" tabindex="0" width="512" height="400"></canvas>
            
            <p class="mt-4 text-xs text-gray-400 game-ui-text">
                Press **ESC** to Pause/Menu. Press **P** to return to the Educational Portal.
            </p>

            <!-- 1. Player Count Selection Modal -->
            <div id="playerCountModal" class="modal fixed inset-0 z-50 flex items-center justify-center">
                <div class="modal-content p-8 rounded-lg text-center game-ui-text w-11/12 max-w-md">
                    <h1 class="text-xl sm:text-2xl mb-6 text-cyan-400">PIXEL DEAD</h1>
                    <h2 class="text-lg sm:text-xl mb-6 text-white">SELECT PLAYERS</h2>
                    <div class="flex flex-col space-y-4">
                        <button id="select1Player" class="snes-button bg-blue-600 border-blue-700 hover:bg-blue-700 active:bg-blue-800">
                            1 PLAYER (Arrows/Mouse)
                        </button>
                        <button id="select2Players" class="snes-button bg-purple-600 border-purple-700 hover:bg-purple-700 active:bg-purple-800">
                            2 PLAYERS (P1: Arrows+Mouse | P2: WASD+Spacebar)
                        </button>
                    </div>
                    <p class="text-xs mt-6 text-gray-400">
                        P1: Arrows to Move, Mouse Click to Shoot. P2: WASD to Move, Spacebar to Shoot.
                        <br>Q/Shift to Swap Weapon.
                    </p>
                </div>
            </div>

            <!-- 2. Difficulty Menu Modal -->
            <div id="difficultyMenuModal" class="modal fixed inset-0 z-50 hidden items-center justify-center">
                <div class="modal-content p-8 rounded-lg text-center game-ui-text w-11/12 max-w-md">
                    <h1 class="text-xl sm:text-2xl mb-6 text-cyan-400">PIXEL DEAD (WAVES MODE)</h1>
                    <h2 class="text-lg sm:text-xl mb-6 text-white">SELECT STARTING DIFFICULTY</h2>
                    <div id="difficultyButtons" class="flex flex-col space-y-4">
                        <!-- Buttons generated by JS -->
                    </div>
                </div>
            </div>
            
            <!-- 3. Pause Menu Modal -->
            <div id="pauseModal" class="modal fixed inset-0 z-50 hidden items-center justify-center">
                <div class="modal-content p-8 rounded-lg text-center game-ui-text w-11/12 max-w-md">
                    <h2 class="text-xl sm:text-2xl mb-6 text-yellow-400">GAME PAUSED</h2>
                    <p id="currentModeDisplay" class="text-sm mb-6 text-white"></p>
                    <div class="flex flex-col space-y-4">
                        <button id="resumeButton" class="snes-button bg-green-600 border-green-700 hover:bg-green-700 active:bg-green-800">
                            Resume Game (ESC)
                        </button>
                        <button id="playTicTacToeButton" class="snes-button bg-gray-600 border-gray-700 hover:bg-gray-700 active:bg-gray-800">
                            Play Tic-Tac-Toe
                        </button>
                        <button id="changeModeButton" class="snes-button bg-red-600 border-red-700 hover:bg-red-700 active:bg-red-800">
                            Change Difficulty / Exit
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- 4. Tic-Tac-Toe Modal -->
            <div id="ticTacToeModal" class="modal fixed inset-0 z-50 hidden items-center justify-center">
                <div class="modal-content p-8 rounded-lg text-center game-ui-text w-11/12 max-w-md">
                    <h2 class="text-xl sm:text-2xl mb-4 text-cyan-400">TIC-TAC-TOE</h2>
                    <p id="tttModeDisplay" class="text-base mb-2 text-red-400"></p>
                    <p id="tttMessage" class="text-base mb-4 text-yellow-300">It is X's turn.</p>
                    
                    <div id="ticTacToeBoard" class="mb-6">
                        <!-- Tic-Tac-Toe Grid renders here -->
                    </div>

                    <div class="flex flex-col space-y-3">
                        <button id="tttRestartButton" class="snes-button bg-green-600 border-green-700 hover:bg-green-700 active:bg-green-800">
                            Restart Game
                        </button>
                        <button id="tttCloseButton" class="snes-button bg-red-600 border-red-700 hover:bg-red-700 active:bg-red-800">
                            Back to Main Menu (ESC)
                        </button>
                    </div>
                </div>
            </div>


            <!-- 5. Game Over Modal -->
            <div id="gameOverModal" class="modal fixed inset-0 z-50 hidden items-center justify-center">
                <div class="modal-content p-8 rounded-lg text-center game-ui-text w-11/12 max-w-md">
                    <h2 class="text-xl sm:text-2xl mb-4 text-red-500">GAME OVER!</h2>
                    <p class="text-lg mb-4 text-yellow-300">WAVES SURVIVED: <span id="wavesSurvived">0</span></p>
                    <p class="text-lg mb-4">P1 Final Score: <span id="finalScore1" class="player-cyan">0</span></p>
                    <p class="text-lg mb-4 hidden" id="p2FinalScoreContainer">P2 Final Score: <span id="finalScore2" class="player-magenta">0</span></p>
                    <p class="text-sm">RESTARTING IN 3 SECONDS...</p>
                </div>
            </div>
        </div>
    </div>


    <script>
        (function() {
            // --- Educational Portal Tab Logic ---
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabPanes = document.querySelectorAll('.tab-pane');

            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const targetTab = button.dataset.tab;

                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');

                    tabPanes.forEach(pane => {
                        pane.classList.add('hidden');
                        if (pane.id === targetTab) {
                            pane.classList.remove('hidden');
                        }
                    });
                });
            });

            // --- Calculator Logic ---
            const calcDisplay = document.getElementById('calcDisplay');
            let displayValue = '0';
            let firstOperand = null;
            let operator = null;
            let waitingForSecondOperand = false;

            function updateCalculatorDisplay() {
                // Limit display to prevent overflow but ensure large numbers are visible
                calcDisplay.textContent = displayValue.substring(0, 15);
            }

            function inputDigit(digit) {
                if (waitingForSecondOperand === true) {
                    displayValue = digit;
                    waitingForSecondOperand = false;
                } else {
                    displayValue = displayValue === '0' ? digit : displayValue + digit;
                }
            }

            function inputDecimal(dot) {
                if (waitingForSecondOperand === true) return;
                
                if (!displayValue.includes(dot)) {
                    displayValue += dot;
                }
            }

            function clearCalculator() {
                displayValue = '0';
                firstOperand = null;
                operator = null;
                waitingForSecondOperand = false;
            }
            
            function negateValue() {
                const value = parseFloat(displayValue);
                if (value !== 0) {
                    displayValue = (value * -1).toString();
                }
            }

            function handleOperator(nextOperator) {
                const inputValue = parseFloat(displayValue);

                if (operator && waitingForSecondOperand)  {
                    operator = nextOperator;
                    return;
                }

                if (firstOperand === null) {
                    firstOperand = inputValue;
                } else if (operator) {
                    const result = calculate(firstOperand, inputValue, operator);
                    
                    displayValue = String(parseFloat(result.toFixed(7)));
                    firstOperand = result;
                }

                waitingForSecondOperand = true;
                operator = nextOperator;
            }

            function calculate(first, second, op) {
                if (op === '+') return first + second;
                if (op === '-') return first - second;
                if (op === '*') return first * second;
                if (op === '/') return first / second;
                return second; 
            }

            const calculator = document.querySelector('.calculator');
            calculator.addEventListener('click', (event) => {
                const { target } = event;
                if (!target.matches('button')) return;

                if (target.dataset.action === 'clear') {
                    clearCalculator();
                } else if (target.dataset.action === 'negate') {
                    negateValue();
                } else if (target.dataset.action === '.') {
                    inputDecimal(target.dataset.value);
                } else if (target.dataset.action === '=') {
                    handleOperator(target.dataset.action);
                    operator = null; // Finalize calculation
                } else if (target.dataset.action) {
                    handleOperator(target.dataset.action);
                } else if (target.dataset.value) {
                    inputDigit(target.dataset.value);
                }

                updateCalculatorDisplay();
            });

            // --- Konami Code Implementation & Core Toggles ---
            const KONAMI_CODE_SEQUENCE = [
                'ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 
                'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight'
            ];
            let konamiCodeIndex = 0;
            
            const educationalContent = document.getElementById('educationalContent');
            const gameContainer = document.getElementById('gameContainer');
            const gameCanvas = document.getElementById('gameCanvas'); // Reference to the canvas

            function showGame() {
                // Ensure the game is stopped before showing
                isGameOver = true;
                isPaused = true;
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                
                educationalContent.classList.add('hidden');
                gameContainer.classList.remove('hidden');
                gameContainer.classList.add('flex');
                
                // CRITICAL: Ensure the canvas has focus to capture keypresses immediately
                gameCanvas.focus();
                
                showPlayerCountMenu();
            }

            function showCover() {
                // Completely hide and reset game state
                isGameOver = true;
                isPaused = true;
                isTicTacToeActive = false;
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                hideAllModals();

                // Show cover page
                gameContainer.classList.add('hidden');
                gameContainer.classList.remove('flex');
                educationalContent.classList.remove('hidden');
            }

            document.addEventListener('keydown', (e) => {
                const key = e.key;

                // 1. Konami Code Check (only when cover is visible)
                if (!educationalContent.classList.contains('hidden')) {
                    if (key === KONAMI_CODE_SEQUENCE[konamiCodeIndex]) {
                        konamiCodeIndex++;
                        if (konamiCodeIndex === KONAMI_CODE_SEQUENCE.length) {
                            showGame();
                            konamiCodeIndex = 0; // Reset for future use
                        }
                    } else if (KONAMI_CODE_SEQUENCE.includes(key)) {
                        // Only reset if the key pressed was one of the expected control keys
                        konamiCodeIndex = 0; 
                        // If the first key was pressed wrong, we still reset
                        if (key === KONAMI_CODE_SEQUENCE[0]) {
                             konamiCodeIndex = 1; // Allows a quick recovery if they mashed 'up' too many times
                        }
                    } else {
                         konamiCodeIndex = 0; // Reset if any other key is pressed
                    }
                }
                
                // 2. Game Exit (P Key)
                if (!gameContainer.classList.contains('hidden') && key.toLowerCase() === 'p') {
                    showCover();
                    e.preventDefault();
                    return; 
                }

                // 3. Regular Game Input Handling (only if game is visible and not in Konami detection)
                if (gameContainer.classList.contains('hidden')) return;

                // --- Existing Game Key Logic ---
                
                players.forEach(p => {
                    p.keys[key.toLowerCase()] = true;
                });
                
                if (key.toLowerCase() === 'escape') {
                    e.preventDefault();
                    if (!isGameOver) {
                        if (isTicTacToeActive) {
                            // If TTT is active, ESC closes TTT and returns to pause menu
                            toggleTicTacToe(); 
                        } else {
                            // If TTT is not active, ESC toggles pause
                            togglePause(); 
                        }
                    }
                }
                
                // P2 Shooting/Melee (Uses Spacebar as dedicated shoot button)
                if (playerCount === 2 && players.length > 1 && players[1].health > 0 && key === ' ') {
                    handleAttack(players[1], true);
                    e.preventDefault();
                }
                
                // Prevent scrolling/default actions for control keys
                const allControlKeys = ['arrowup', 'arrowdown', 'arrowleft', 'arrowright', 'w', 'a', 's', 'd', 'shift', 'q', ' '];
                if (allControlKeys.includes(key.toLowerCase())) {
                    e.preventDefault();
                }
            });
            
            document.addEventListener('keyup', (e) => {
                if (gameContainer.classList.contains('hidden')) return;
                const key = e.key.toLowerCase();
                players.forEach(p => {
                    p.keys[key] = false;
                });
            });


            // --- Game Constants and Setup ---
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const W = canvas.width;
            const H = canvas.height;

            // UI Elements
            const score1Display = document.getElementById('score1Display');
            const score2Display = document.getElementById('score2Display');
            const health1Display = document.getElementById('health1Display');
            const health2Display = document.getElementById('health2Display');
            const weaponDisplay = document.getElementById('weaponDisplay'); 
            const p2UiGroup = document.getElementById('p2UiGroup');
            const waveDisplay = document.getElementById('waveDisplay');
            const wavesSurvivedDisplay = document.getElementById('wavesSurvived');
            
            const gameOverModal = document.getElementById('gameOverModal');
            const finalScore1Display = document.getElementById('finalScore1');
            const finalScore2Display = document.getElementById('finalScore2');
            const p2FinalScoreContainer = document.getElementById('p2FinalScoreContainer');
            
            const playerCountModal = document.getElementById('playerCountModal');
            const select1PlayerButton = document.getElementById('select1Player');
            const select2PlayersButton = document.getElementById('select2Players');

            const difficultyMenuModal = document.getElementById('difficultyMenuModal');
            const difficultyButtonsContainer = document.getElementById('difficultyButtons');
            const pauseModal = document.getElementById('pauseModal');
            const currentModeDisplay = document.getElementById('currentModeDisplay');
            const resumeButton = document.getElementById('resumeButton');
            const changeModeButton = document.getElementById('changeModeButton');

            // Tic-Tac-Toe elements
            const ticTacToeModal = document.getElementById('ticTacToeModal');
            const ticTacToeBoard = document.getElementById('ticTacToeBoard');
            const tttModeDisplay = document.getElementById('tttModeDisplay');
            const tttMessage = document.getElementById('tttMessage');
            const playTicTacToeButton = document.getElementById('playTicTacToeButton');
            const tttRestartButton = document.getElementById('tttRestartButton');
            const tttCloseButton = document.getElementById('tttCloseButton');
            
            // Game State Flags and Variables
            let isGameOver = true;
            let isPaused = false;
            let isTicTacToeActive = false;
            let lastUpdateTime = 0;
            let animationFrameId = null; // Initialize to null
            let currentDifficulty = null; 
            let playerCount = 1; 
            let currentWave = 0; 
            let zombiesPerWave = 0; 
            let zombiesRemainingToSpawn = 0; 
            let rpgPacks = []; 

            // Tic-Tac-Toe Game State
            let tictactoe = {
                board: Array(9).fill(null),
                currentPlayer: 'X',
                status: 'playing', 
                message: 'It is X\'s turn.',
                playerTurn: 1, 
                playerMode: '2P' 
            };
            
            // Damage feedback constants
            const HIT_FLASH_DURATION = 15; 
            
            // --- DIFFICULTY PRESETS ---
            const DIFFICULTIES = {
                EASY: { name: "Easy", color: "text-green-400", zombieSpeedMultiplier: 0.8, zombieHealthMultiplier: 0.75, baseZombies: 20, playerHealth: 150, scoreMultiplier: 1.0, },
                MEDIUM: { name: "Medium", color: "text-yellow-400", zombieSpeedMultiplier: 1.0, zombieHealthMultiplier: 1.0, baseZombies: 30, playerHealth: 100, scoreMultiplier: 1.5, },
                HARD: { name: "Hard", color: "text-orange-400", zombieSpeedMultiplier: 1.2, zombieHealthMultiplier: 1.5, baseZombies: 40, playerHealth: 75, scoreMultiplier: 2.0, },
                SUPER_HARD: { name: "Super Hard", color: "text-red-500", zombieSpeedMultiplier: 1.5, zombieHealthMultiplier: 2.0, baseZombies: 50, playerHealth: 50, scoreMultiplier: 3.0, }
            };
            
            // --- WEAPON CONFIGURATIONS ---
            const WEAPONS = {
                SHOTGUN: { type: 'ranged', fireRate: 350, bulletDamage: 1, bulletSpeed: 10, name: "Shotgun" },
                KNIFE: { type: 'melee', fireRate: 500, damage: 2, range: 20, name: "Machete" },
                RPG: { type: 'ranged_aoe', fireRate: 1500, bulletDamage: 15, bulletSpeed: 5, name: "RPG" }
            };

            // --- PLAYER TEMPLATES & State ---
            const BASE_PLAYER_CONFIG = {
                size: 16,
                speed: 4,
                isSwapping: false,
                rpgAmmo: 0,
                score: 0,
                health: 100,
                maxHealth: 100,
                hitFlashTimer: 0,
                keys: {},
                lastShotTime: 0,
                weapon: WEAPONS.SHOTGUN,
            };

            const PLAYER_TEMPLATES = [
                // Player 1 (P1 - Arrows + Mouse)
                {
                    id: 1,
                    color: '#00ffff', // Cyan
                    controlKeys: { up: ['arrowup'], down: ['arrowdown'], left: ['arrowleft'], right: ['arrowright'], swap: ['shift'] },
                    isMouseControlled: true,
                    x: W / 3,
                    y: H / 2,
                    lastMoveDir: { dx: 1, dy: 0 }, 
                    ...BASE_PLAYER_CONFIG
                },
                // Player 2 (P2 - WASD + Directional Shot)
                {
                    id: 2,
                    color: '#ff00ff', // Magenta
                    controlKeys: { up: ['w'], down: ['s'], left: ['a'], right: ['d'], swap: ['q'] },
                    isMouseControlled: false,
                    x: W * 2 / 3,
                    y: H / 2,
                    lastMoveDir: { dx: -1, dy: 0 },
                    ...BASE_PLAYER_CONFIG
                }
            ];

            // Game State Objects
            let players = []; 
            let bullets = [];
            let zombies = [];
            let healPacks = []; 
            let scorePopups = []; 
            
            let mouse = { x: 0, y: 0, clicked: false }; 
            let zombieSpawnTimer = 0;
            let healSpawnTimer = 0; 
            let ZOMBIE_SPAWN_INTERVAL = 120;
            const RPG_PACK_SIZE = 14;
            const RPG_BLAST_RADIUS = 60;
            const HEAL_PACK_SIZE = 10;
            const HEAL_AMOUNT = 25; 
            const HEAL_SPAWN_INTERVAL = 300;
            const ZOMBIE_TYPES_BASE = {
                NORMAL: { health: 3, size: 16, speedBase: 0.8, score: 100, bodyColor: '#4b5563', headColor: '#9acd32' }, 
                TANK: { health: 10, size: 24, speedBase: 0.5, score: 500, bodyColor: '#8b0000', headColor: '#daa520' } 
            };

            // --- UI/Modal Logic ---
            function hideAllModals() {
                [playerCountModal, difficultyMenuModal, pauseModal, gameOverModal, ticTacToeModal].forEach(m => {
                    m.classList.add('hidden');
                    m.classList.remove('flex');
                });
            }
            
            function showPlayerCountMenu() {
                if (gameContainer.classList.contains('hidden')) return; // Only show if game is active
                
                isGameOver = true;
                isPaused = true;
                isTicTacToeActive = false; 
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                
                hideAllModals();
                playerCountModal.classList.remove('hidden');
                playerCountModal.classList.add('flex');
            }

            function showDifficultyMenu(count) {
                playerCount = count;
                hideAllModals();
                
                difficultyMenuModal.classList.remove('hidden');
                difficultyMenuModal.classList.add('flex');
            }

            function generateDifficultyButtons() {
                difficultyButtonsContainer.innerHTML = '';
                Object.keys(DIFFICULTIES).forEach(key => {
                    const diff = DIFFICULTIES[key];
                    const button = document.createElement('button');
                    button.className = `snes-button ${diff.color.replace('text-', 'bg-')}`;
                    button.textContent = `${diff.name.toUpperCase()} (Health: ${diff.playerHealth} | Start Zombies: ${diff.baseZombies})`;
                    button.onclick = () => startGame(diff);
                    difficultyButtonsContainer.appendChild(button);
                });
            }
            
            function startGame(difficulty) {
                currentDifficulty = difficulty;
                
                hideAllModals();
                initGame();
                startNewWave(); 
            }
            
            // --- NEW TIC-TAC-TOE LOGIC ---

            function checkWin(board) {
                const lines = [
                    [0, 1, 2], [3, 4, 5], [6, 7, 8],
                    [0, 3, 6], [1, 4, 7], [2, 5, 8],
                    [0, 4, 8], [2, 4, 6],
                ];
                for (let i = 0; i < lines.length; i++) {
                    const [a, b, c] = lines[i];
                    if (board[a] && board[a] === board[b] && board[a] === board[c]) {
                        return board[a]; 
                    }
                }
                return null;
            }

            function checkDraw(board) {
                return board.every(cell => cell !== null);
            }
            
            function minimax(board, depth, isMaximizing) {
                const winner = checkWin(board);
                
                if (winner === 'O') return 10 - depth; 
                if (winner === 'X') return -10 + depth; 
                if (checkDraw(board)) return 0; 

                const availableMoves = board
                    .map((cell, index) => cell === null ? index : null)
                    .filter(index => index !== null);
                
                if (isMaximizing) { 
                    let bestScore = -Infinity;
                    for (const move of availableMoves) {
                        board[move] = 'O';
                        const score = minimax(board, depth + 1, false);
                        board[move] = null; 
                        bestScore = Math.max(score, bestScore);
                    }
                    return bestScore;
                } else { 
                    let bestScore = Infinity;
                    for (const move of availableMoves) {
                        board[move] = 'X';
                        const score = minimax(board, depth + 1, true);
                        board[move] = null; 
                        bestScore = Math.min(score, bestScore);
                    }
                    return bestScore;
                }
            }

            function getBestMove(board) {
                let bestScore = -Infinity;
                let bestMove = null;
                const availableMoves = board
                    .map((cell, index) => cell === null ? index : null)
                    .filter(index => index !== null);

                if (board[4] === null) return 4;

                for (const move of availableMoves) {
                    board[move] = 'O';
                    const score = minimax(board, 0, false); 
                    board[move] = null; 
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = move;
                    }
                }
                return bestMove;
            }


            function makeAIMove() {
                if (tictactoe.status !== 'playing') return;
                
                const move = getBestMove(tictactoe.board);

                if (move !== null) {
                    makeMove(move, true);
                }
            }

            function makeMove(index, isAI = false) {
                if (tictactoe.status !== 'playing' || tictactoe.board[index] !== null) {
                    return;
                }

                if (!isAI && tictactoe.playerMode === 'AI' && tictactoe.currentPlayer === 'O') {
                    return;
                }

                tictactoe.board[index] = tictactoe.currentPlayer;
                
                const winner = checkWin(tictactoe.board);
                
                if (winner) {
                    tictactoe.status = 'win';
                    tictactoe.message = `${winner === 'X' ? 'P1 (X)' : tictactoe.playerMode === 'AI' ? 'AI (O)' : 'P2 (O)'} WINS!`;
                } else if (checkDraw(tictactoe.board)) {
                    tictactoe.status = 'draw';
                    tictactoe.message = 'It\'s a DRAW!';
                } else {
                    tictactoe.currentPlayer = tictactoe.currentPlayer === 'X' ? 'O' : 'X';
                    tictactoe.playerTurn = tictactoe.playerTurn === 1 ? 2 : 1;
                    
                    if (tictactoe.playerMode === 'AI') {
                        tictactoe.message = tictactoe.currentPlayer === 'X' ? 'It is P1 (X)\'s turn.' : 'Unbeatable AI (O) is thinking...';
                    } else {
                        tictactoe.message = `It is P${tictactoe.playerTurn} (${tictactoe.currentPlayer})'s turn.`;
                    }
                    
                    if (tictactoe.playerMode === 'AI' && tictactoe.currentPlayer === 'O') {
                        renderTicTacToe();
                        setTimeout(makeAIMove, 500); 
                    }
                }

                renderTicTacToe();
            }

            function renderTicTacToe() {
                tttMessage.textContent = tictactoe.message;
                ticTacToeBoard.innerHTML = '';
                
                if (tictactoe.playerMode === 'AI') {
                    tttModeDisplay.textContent = 'MODE: P1 (X) vs UNBEATABLE AI (O)';
                    tttModeDisplay.classList.remove('text-green-400');
                    tttModeDisplay.classList.add('text-red-400');
                } else {
                    tttModeDisplay.textContent = 'MODE: P1 (X) vs P2 (O)';
                    tttModeDisplay.classList.remove('text-red-400');
                    tttModeDisplay.classList.add('text-green-400');
                }

                const grid = document.createElement('div');
                grid.className = "grid grid-cols-3 gap-1 w-64 h-64 mx-auto border-4 border-yellow-400 p-1";

                tictactoe.board.forEach((cell, index) => {
                    const cellDiv = document.createElement('div');
                    cellDiv.className = "flex items-center justify-center text-5xl font-bold bg-[#444455] ttt-cell";
                    cellDiv.textContent = cell || '';
                    cellDiv.dataset.index = index;
                    
                    if (cell === 'X') {
                        cellDiv.classList.add('player-cyan');
                    } else if (cell === 'O') {
                        cellDiv.classList.add('player-magenta');
                    }
                    
                    if (tictactoe.status === 'playing' && !cell) {
                        const isPlayersTurn = (tictactoe.playerMode === '2P') || 
                                              (tictactoe.playerMode === 'AI' && tictactoe.currentPlayer === 'X');

                        if (isPlayersTurn) {
                            cellDiv.classList.add('hover:bg-[#555566]', 'cursor-pointer');
                            cellDiv.onclick = () => makeMove(index);
                        } else {
                            cellDiv.style.cursor = 'default';
                        }

                    } else {
                        cellDiv.style.cursor = 'default';
                    }
                    
                    grid.appendChild(cellDiv);
                });
                ticTacToeBoard.appendChild(grid);
            }

            function initTicTacToe() {
                tictactoe = {
                    board: Array(9).fill(null),
                    currentPlayer: 'X',
                    status: 'playing',
                    message: 'It is X\'s turn (P1).',
                    playerTurn: 1,
                    playerMode: playerCount === 1 ? 'AI' : '2P' 
                };
                
                if (tictactoe.playerMode === 'AI') {
                    tictactoe.message = 'It is P1 (X)\'s turn.';
                } else {
                    tictactoe.message = 'It is P1 (X)\'s turn.';
                }
                
                renderTicTacToe();
            }

            function toggleTicTacToe() {
                if (isGameOver) return; 

                if (isTicTacToeActive) {
                    isTicTacToeActive = false;
                    ticTacToeModal.classList.add('hidden');
                    ticTacToeModal.classList.remove('flex');
                    
                    pauseModal.classList.remove('hidden');
                    pauseModal.classList.add('flex');
                } else {
                    isTicTacToeActive = true;
                    isPaused = true; 
                    
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }

                    hideAllModals(); 
                    ticTacToeModal.classList.remove('hidden');
                    ticTacToeModal.classList.add('flex');
                    
                    initTicTacToe(); 
                }
            }
            // --- END TIC-TAC-TOE LOGIC ---


            function togglePause() {
                if (isGameOver) return;
                
                if (isTicTacToeActive) {
                    toggleTicTacToe();
                    return;
                }

                isPaused = !isPaused;

                if (isPaused) {
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }
                    currentModeDisplay.textContent = `Current Mode: ${currentDifficulty.name.toUpperCase()} (Wave ${currentWave})`;
                    pauseModal.classList.remove('hidden');
                    pauseModal.classList.add('flex');
                } else {
                    pauseModal.classList.add('hidden');
                    pauseModal.classList.remove('flex');

                    lastUpdateTime = performance.now();
                    animationFrameId = requestAnimationFrame(gameLoop);
                }
            }
            
            function startNewWave() {
                currentWave++;
                
                const baseZombies = currentDifficulty.baseZombies;
                zombiesPerWave = Math.ceil(baseZombies + (currentWave - 1) * (baseZombies / 10));
                zombiesRemainingToSpawn = zombiesPerWave;
                
                ZOMBIE_SPAWN_INTERVAL = Math.max(
                    currentDifficulty.spawnIntervalFrames || 120, 
                    Math.max(30, 120 - (currentWave - 1) * 5)
                );
                
                healPacks = [];
                rpgPacks = [];
                
                players.forEach((p, index) => {
                     if (p.health > 0) {
                         spawnRPGPack(p.x + (index * 40) - 20, p.y);
                         scorePopups.push({ text: `WAVE ${currentWave-1} CLEARED!`, x: p.x, y: p.y - 30, life: 120, vy: -0.2, color: '#ffcc00' });
                     }
                });

                if (currentWave % 5 === 0) {
                    players.forEach(p => {
                        p.health = Math.min(p.maxHealth, p.health + HEAL_AMOUNT);
                        scorePopups.push({ text: `BONUS HEALTH!`, x: p.x, y: p.y - 50, life: 90, vy: -0.3, color: '#00ff00' });
                    });
                }
            }


            // --- Drawing Helpers (omitted for brevity, assume contents are the same as original) ---
            function drawBlock(x, y, w, h, color) {
                ctx.fillStyle = color;
                ctx.fillRect(Math.round(x), Math.round(y), w, h);
            }
            
            function drawPlayer(p) {
                const s = p.size; 
                const x = p.x;
                const y = p.y;
                const playerColor = p.color;
                
                const skinColor = '#ffdbac'; 
                const pantsColor = '#222222'; 
                const bootColor = '#111111';
                const armorColor = '#888888';
                
                const headSize = 8; 
                const torsoWidth = 10; 
                const torsoHeight = 8; 
                const legWidth = 4;
                const legHeight = 6;
                const bootHeight = 2;

                const totalHeight = headSize + torsoHeight + legHeight + bootHeight;
                let currentY = y - totalHeight / 2;
                
                drawBlock(x - headSize / 2, currentY, headSize, headSize, skinColor);
                drawBlock(x - headSize / 2, currentY + 1, headSize, 2, playerColor);
                currentY += headSize;

                const torsoY = currentY;
                drawBlock(x - torsoWidth / 2, torsoY, torsoWidth, torsoHeight, pantsColor);
                drawBlock(x - torsoWidth / 2 + 1, torsoY + 1, torsoWidth - 2, torsoHeight - 2, armorColor);
                drawBlock(x - 1, torsoY + 2, 2, 4, playerColor); 
                
                const armWidth = 3;
                drawBlock(x - torsoWidth / 2 - armWidth, torsoY, armWidth, torsoHeight, pantsColor); 
                drawBlock(x + torsoWidth / 2, torsoY, armWidth, torsoHeight, pantsColor); 
                currentY += torsoHeight;
                
                const legGap = torsoWidth - (legWidth * 2);
                const gapHalf = Math.max(1, Math.round(legGap / 2));
                
                drawBlock(x - legWidth - gapHalf, currentY, legWidth, legHeight, pantsColor); 
                drawBlock(x + gapHalf, currentY, legWidth, legHeight, pantsColor); 
                currentY += legHeight;
                
                drawBlock(x - legWidth - gapHalf, currentY, legWidth, bootHeight, bootColor); 
                drawBlock(x + gapHalf, currentY, legWidth, bootHeight, bootColor); 

                let dx, dy;
                if (p.isMouseControlled) {
                    dx = mouse.x - x;
                    dy = mouse.y - y;
                } else {
                    dx = p.lastMoveDir.dx;
                    dy = p.lastMoveDir.dy;
                }
                const angle = Math.atan2(dy, dx);
                
                const weapon = p.weapon;
                const isRpg = weapon.type === 'ranged_aoe';
                const armLength = 8; 
                const gunPivotX = x + Math.cos(angle) * armLength * 0.2; 
                const gunPivotY = y + Math.sin(angle) * armLength * 0.2;

                ctx.save();
                ctx.translate(gunPivotX, gunPivotY);
                ctx.rotate(angle);

                if (weapon.type === 'ranged' || weapon.type === 'ranged_aoe') {
                    const barrelLength = isRpg ? 18 : 12;
                    const barrelThickness = isRpg ? 6 : 4;
                    const handleLength = 4;
                    
                    ctx.fillStyle = isRpg ? '#4b4b4b' : '#666666';
                    drawBlock(0, -barrelThickness / 2, barrelLength, barrelThickness, ctx.fillStyle);
                    
                    if (isRpg) {
                        drawBlock(barrelLength - 3, -barrelThickness / 2 + 1, 3, barrelThickness - 2, '#ff4500'); 
                    }

                    ctx.fillStyle = '#444444';
                    drawBlock(-handleLength, -2 / 2, handleLength, 2, ctx.fillStyle);
                } else if (weapon.type === 'melee') {
                    const bladeLength = 16;
                    const handleLength = 4;
                    
                    ctx.fillStyle = '#ccaa66'; 
                    drawBlock(-handleLength, -1, handleLength, 2, ctx.fillStyle);

                    ctx.fillStyle = '#bbbbbb'; 
                    ctx.beginPath();
                    ctx.moveTo(0, 2);
                    ctx.lineTo(bladeLength, 0);
                    ctx.lineTo(0, -2);
                    ctx.fill();
                }
                ctx.restore();

                const barWidth = 24;
                const barHeight = 4;
                const barX = x - barWidth / 2;
                const barY = y - totalHeight / 2 - 6; 
                const healthRatio = p.health / p.maxHealth;
                const filledWidth = barWidth * healthRatio;

                drawBlock(barX - 1, barY - 1, barWidth + 2, barHeight + 2, '#000000'); 
                drawBlock(barX, barY, barWidth, barHeight, '#444444');

                if (filledWidth > 0) {
                    let healthColor = '#00ff00';
                    if (healthRatio < 0.5) healthColor = '#ffcc00';
                    if (healthRatio < 0.25) healthColor = '#ff0000';
                    drawBlock(barX, barY, filledWidth, barHeight, healthColor);
                }
            }
            
            function drawHealPack(pack) {
                const s = HEAL_PACK_SIZE;
                drawBlock(pack.x - s / 2, pack.y - s / 2, s, s, '#ff0000'); 
                drawBlock(pack.x - 1, pack.y - s / 2 + 2, 2, s - 4, '#ffffff'); 
                drawBlock(pack.x - s / 2 + 2, pack.y - 1, s - 4, 2, '#ffffff'); 
            }
            
            function drawRpgPack(pack) {
                const s = RPG_PACK_SIZE;
                drawBlock(pack.x - s / 2, pack.y - s / 2, s, s, '#4b4b4b'); 
                drawBlock(pack.x - s / 4, pack.y - s / 2 + 2, s / 2, s - 4, '#ff4500'); 
                drawBlock(pack.x - 2, pack.y - 2, 4, 4, '#ffcc00'); 
            }

            function drawZombie(zombie) {
                const s = zombie.size; 
                const x = zombie.x;
                const y = zombie.y;
                
                const healthRatio = zombie.health / zombie.type.health;
                
                const bodyBaseColor = zombie.type.bodyColor; 
                const headBaseColor = zombie.type.headColor; 
                const limbColor = '#111111'; 
                const accentColor = '#8b0000'; 

                const hColor = healthRatio < 0.3 ? '#ff0000' : headBaseColor;
                
                const headSize = Math.max(6, Math.round(s * 0.4)); 
                const torsoWidth = Math.max(10, Math.round(s * 0.7)); 
                const torsoHeight = Math.round(s * 0.6); 
                const legWidth = Math.max(3, Math.round(s * 0.2));
                const legHeight = Math.round(s * 0.5);
                const armWidth = 3;
                const armHeight = torsoHeight + 4; 

                const totalHeight = headSize + torsoHeight + legHeight;
                let currentY = y - totalHeight / 2;
                const torsoXOffset = -1;
                
                const headX = x - headSize / 2;
                drawBlock(headX, currentY, headSize, headSize, hColor);
                drawBlock(headX + 1, currentY + 1, 1, 1, accentColor);
                drawBlock(headX + headSize - 2, currentY + 2, 2, 2, accentColor);
                drawBlock(headX + 1, currentY + 2, 1, 1, '#000000'); 
                drawBlock(headX + headSize - 2, currentY + 2, 1, 1, '#000000'); 
                currentY += headSize;
                drawBlock(x - 2, currentY - 1, 4, 1, '#222'); 
                currentY -= 1; 

                const torsoY = currentY;
                const bodyShade = '#374151'; 
                drawBlock(x - torsoWidth / 2 + torsoXOffset, torsoY, torsoWidth, torsoHeight, bodyBaseColor);
                drawBlock(x - torsoWidth / 2 + torsoXOffset, torsoY, 2, torsoHeight, bodyShade); 
                drawBlock(x - torsoWidth / 2 + torsoXOffset, torsoY + torsoHeight - 2, torsoWidth, 2, bodyShade); 
                drawBlock(x - 1 + torsoXOffset, torsoY, 2, torsoHeight, limbColor); 
                
                drawBlock(x - torsoWidth / 2 - armWidth + torsoXOffset, torsoY, armWidth, 4, limbColor); 
                drawBlock(x - torsoWidth / 2 - armWidth + torsoXOffset + 1, torsoY + 4, armWidth - 1, armHeight - 4, limbColor); 

                drawBlock(x + torsoWidth / 2 + torsoXOffset, torsoY, armWidth, 4, limbColor); 
                drawBlock(x + torsoWidth / 2 + torsoXOffset, torsoY + 4, armWidth - 1, armHeight - 4, limbColor); 
                
                currentY += torsoHeight;
                
                const legGap = torsoWidth - (legWidth * 2);
                const gapHalf = Math.max(1, Math.round(legGap / 2));
                
                drawBlock(x - legWidth - gapHalf + torsoXOffset, currentY, legWidth, legHeight, bodyBaseColor);
                drawBlock(x - legWidth - gapHalf + torsoXOffset, currentY + legHeight - 2, legWidth, 2, limbColor); 

                const rightLegOffset = 1;
                drawBlock(x + gapHalf + torsoXOffset + rightLegOffset, currentY, legWidth, legHeight - 2, bodyBaseColor);
                drawBlock(x + gapHalf + torsoXOffset + rightLegOffset, currentY + legHeight - 2, legWidth, 2, limbColor); 

                if (healthRatio < 1) {
                     const barWidth = torsoWidth + 2;
                     const barHeight = 2;
                     const barX = x - barWidth / 2;
                     const barY = y - totalHeight / 2 - 4; 
                     const filledWidth = barWidth * healthRatio;
                     
                     drawBlock(barX, barY, barWidth, barHeight, '#444444');
                     drawBlock(barX, barY, filledWidth, barHeight, '#ff0000');
                }
            }
            // --- End Drawing Helpers ---


            // --- Core Game Logic ---

            function updateUI() {
                score1Display.textContent = `P1 SCORE: ${String(players[0].score).padStart(5, '0')} (${currentDifficulty.scoreMultiplier}x)`;
                health1Display.textContent = `P1 HEALTH: ${Math.max(0, players[0].health)}`; 
                
                if (playerCount === 2) {
                    p2UiGroup.classList.remove('hidden');
                    score2Display.textContent = `P2 SCORE: ${String(players[1].score).padStart(5, '0')} (${currentDifficulty.scoreMultiplier}x)`;
                    health2Display.textContent = `P2 HEALTH: ${Math.max(0, players[1].health)}`; 
                } else {
                    p2UiGroup.classList.add('hidden');
                }
                
                waveDisplay.textContent = `WAVE ${currentWave} / ZOMBIES: ${zombies.length + zombiesRemainingToSpawn}`;

                weaponDisplay.textContent = `WEAPON: ${players[0].weapon.name}${players[0].weapon === WEAPONS.RPG ? ` (${players[0].rpgAmmo})` : ''}${playerCount === 2 ? ` | P2 WEAPON: ${players[1].weapon.name}${players[1].weapon === WEAPONS.RPG ? ` (${players[1].rpgAmmo})` : ''}` : ''}`;
            }

            function spawnZombie() {
                if (zombiesRemainingToSpawn <= 0) return;

                const diff = currentDifficulty;

                const typeKey = Math.random() < 0.2 ? 'TANK' : 'NORMAL';
                const baseType = ZOMBIE_TYPES_BASE[typeKey];
                
                const waveMult = 1 + (currentWave - 1) * 0.1; 

                const size = baseType.size;
                const speed = baseType.speedBase * diff.zombieSpeedMultiplier * waveMult; 
                const health = Math.ceil(baseType.health * diff.zombieHealthMultiplier * waveMult);
                
                let x, y;
                const side = Math.floor(Math.random() * 4);
                switch (side) {
                    case 0: x = Math.random() * W; y = -size; break; 
                    case 1: x = Math.random() * W; y = H + size; break;
                    case 2: x = -size; y = Math.random() * H; break;
                    case 3: x = W + size; y = Math.random() * H; break;
                }

                zombies.push({ 
                    x, 
                    y, 
                    size, 
                    speed, 
                    health, 
                    type: baseType 
                });
                zombiesRemainingToSpawn--;
            }
            
            function spawnHealPack(x = Math.random() * (W - 40) + 20, y = Math.random() * (H - 40) + 20) {
                 healPacks.push({ x, y, size: HEAL_PACK_SIZE });
            }

            function spawnRPGPack(x = Math.random() * (W - 40) + 20, y = Math.random() * (H - 40) + 20) {
                 rpgPacks.push({ x, y, size: RPG_PACK_SIZE });
            }

            function fireRangedWeapon(p) {
                let dx, dy;
                
                if (p.isMouseControlled) {
                    dx = mouse.x - p.x;
                    dy = mouse.y - p.y;
                } else { 
                    dx = p.lastMoveDir.dx;
                    dy = p.lastMoveDir.dy;
                }
                const angle = Math.atan2(dy, dx);
                
                const weapon = p.weapon;
                const isRpg = weapon.type === 'ranged_aoe';

                if (isRpg) {
                    if (p.rpgAmmo > 0) {
                        p.rpgAmmo--; 
                    } else {
                        p.weapon = WEAPONS.SHOTGUN; 
                        return;
                    }
                }

                bullets.push({
                    x: p.x,
                    y: p.y,
                    vx: Math.cos(angle) * weapon.bulletSpeed,
                    vy: Math.sin(angle) * weapon.bulletSpeed,
                    radius: isRpg ? 6 : 3, 
                    color: isRpg ? '#ff4500' : p.color, 
                    damage: weapon.bulletDamage,
                    isRpg: isRpg, 
                    blastRadius: isRpg ? RPG_BLAST_RADIUS : 0,
                    shooterId: p.id 
                });
                
                if (p.rpgAmmo === 0 && p.weapon === WEAPONS.RPG) {
                    p.weapon = WEAPONS.SHOTGUN;
                }
            }

            function performMeleeAttack(p) {
                const weapon = p.weapon;
                for (let j = zombies.length - 1; j >= 0; j--) {
                    const zombie = zombies[j];
                    const dx = zombie.x - p.x;
                    const dy = zombie.y - p.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < p.size / 2 + weapon.range) {
                        zombie.health -= weapon.damage;
                        
                        if (zombie.health <= 0) {
                            const earnedScore = Math.floor(zombie.type.score * currentDifficulty.scoreMultiplier);
                            scorePopups.push({ text: `+${earnedScore} (P${p.id})`, x: zombie.x, y: zombie.y, life: 60, vy: -0.5, color: p.color });
                            p.score += earnedScore;
                            zombies.splice(j, 1);
                        }
                    }
                }
            }

            function handleAttack(p, isKeyTriggered = false) {
                if (p.health <= 0) return;
                
                if (p.isMouseControlled && !mouse.clicked) return; 
                if (!p.isMouseControlled && !isKeyTriggered) return;

                const currentTime = Date.now();
                if (currentTime - p.lastShotTime < p.weapon.fireRate) {
                    return; 
                }

                p.lastShotTime = currentTime; 

                if (p.weapon.type === 'ranged' || p.weapon.type === 'ranged_aoe') {
                    fireRangedWeapon(p);
                } else if (p.weapon.type === 'melee') {
                    performMeleeAttack(p);
                }
            }


            function handleInput() {
                if (isGameOver || isPaused || isTicTacToeActive) return;

                players.forEach(p => {
                    if (p.health <= 0) return;

                    let movedX = 0;
                    let movedY = 0;

                    const speed = p.speed;
                    if (p.controlKeys.up.some(key => p.keys[key])) { p.y -= speed; movedY = -1; }
                    if (p.controlKeys.down.some(key => p.keys[key])) { p.y += speed; movedY = 1; }
                    if (p.controlKeys.left.some(key => p.keys[key])) { p.x -= speed; movedX = -1; }
                    if (p.controlKeys.right.some(key => p.keys[key])) { p.x += speed; movedX = 1; }

                    if (movedX !== 0 || movedY !== 0) {
                        p.lastMoveDir = { dx: movedX, dy: movedY };
                    }

                    p.x = Math.max(p.size / 2, Math.min(W - p.size / 2, p.x));
                    p.y = Math.max(p.size / 2, Math.min(H - p.size / 2, p.y));

                    if (p.controlKeys.swap.some(key => p.keys[key])) {
                        if (!p.isSwapping) {
                            p.isSwapping = true; 
                            
                            if (p.weapon === WEAPONS.SHOTGUN) {
                                p.weapon = (p.rpgAmmo > 0) ? WEAPONS.RPG : WEAPONS.KNIFE;
                            } else if (p.weapon === WEAPONS.KNIFE) {
                                p.weapon = (p.rpgAmmo > 0) ? WEAPONS.RPG : WEAPONS.SHOTGUN;
                            } else if (p.weapon === WEAPONS.RPG) {
                                p.weapon = WEAPONS.SHOTGUN;
                            }
                        }
                    } else {
                        p.isSwapping = false; 
                    }
                    
                    if (p.weapon === WEAPONS.RPG && p.rpgAmmo <= 0) {
                        p.weapon = WEAPONS.SHOTGUN; 
                    }
                });
                
                if (players.length > 0 && players[0].isMouseControlled) {
                    handleAttack(players[0]);
                }
            }

            function updateGame(deltaTime) {
                if (isPaused || isTicTacToeActive) return;

                players.forEach(p => {
                    if (p.health > 0 && p.hitFlashTimer > 0) {
                        p.hitFlashTimer--;
                    }
                });

                scorePopups = scorePopups.filter(popup => {
                    if (popup.vy) {
                        popup.y += popup.vy; 
                    }
                    popup.life--;
                    return popup.life > 0;
                });
                
                bullets = bullets.filter(bullet => {
                    bullet.x += bullet.vx;
                    bullet.y += bullet.vy;
                    return bullet.x > -W && bullet.x < W * 2 && bullet.y > -H && bullet.y < H * 2;
                });

                zombies.forEach(zombie => {
                    let closestPlayer = null;
                    let minDist = Infinity;

                    players.forEach(p => {
                        if (p.health > 0) {
                            const dist = Math.sqrt(Math.pow(p.x - zombie.x, 2) + Math.pow(p.y - zombie.y, 2));
                            if (dist < minDist) {
                                minDist = dist;
                                closestPlayer = p;
                            }
                        }
                    });

                    if (closestPlayer) {
                        const dx = closestPlayer.x - zombie.x;
                        const dy = closestPlayer.y - zombie.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        zombie.x += (dx / dist) * zombie.speed;
                        zombie.y += (dy / dist) * zombie.speed;

                        if (dist < closestPlayer.size / 2 + zombie.size / 2) {
                            if (closestPlayer.hitFlashTimer <= 0) { 
                                if (closestPlayer.health > 0) {
                                    closestPlayer.health -= 5; 
                                    closestPlayer.hitFlashTimer = HIT_FLASH_DURATION; 
                                }
                                closestPlayer.x -= (dx / dist) * 5; 
                                closestPlayer.y -= (dy / dist) * 5;
                            }
                        }
                    }
                });

                for (let i = bullets.length - 1; i >= 0; i--) {
                    const bullet = bullets[i];
                    const shooter = players.find(p => p.id === bullet.shooterId);
                    let hit = false;
                    let explosionCenter = null; 

                    for (let j = zombies.length - 1; j >= 0; j--) {
                        const zombie = zombies[j];
                        const dx = bullet.x - zombie.x;
                        const dy = bullet.y - zombie.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < zombie.size / 2 + bullet.radius) {
                            zombie.health -= bullet.damage; 
                            hit = true;
                            explosionCenter = { x: bullet.x, y: bullet.y }; 
                            
                            if (!bullet.isRpg) { 
                                 if (zombie.health <= 0) {
                                     const earnedScore = Math.floor(zombie.type.score * currentDifficulty.scoreMultiplier);
                                     scorePopups.push({ text: `+${earnedScore} (P${shooter.id})`, x: zombie.x, y: zombie.y, life: 60, vy: -0.5, color: shooter.color });
                                     shooter.score += earnedScore; 
                                     zombies.splice(j, 1);
                                 }
                                break; 
                            } 
                        }
                    }

                    const offScreen = bullet.x < -10 || bullet.x > W + 10 || bullet.y < -10 || bullet.y > H + 10;
                    
                    if (bullet.isRpg && (hit || offScreen)) {
                        explosionCenter = explosionCenter || { x: bullet.x, y: bullet.y };
                        
                        for (let j = zombies.length - 1; j >= 0; j--) {
                            const zombie = zombies[j];
                            const dx = explosionCenter.x - zombie.x;
                            const dy = explosionCenter.y - zombie.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist < bullet.blastRadius) {
                                const proximity = 1 - (dist / bullet.blastRadius); 
                                const aoeDamage = Math.ceil(bullet.damage * proximity);
                                zombie.health -= aoeDamage;

                                if (zombie.health <= 0) {
                                    const earnedScore = Math.floor(zombie.type.score * currentDifficulty.scoreMultiplier);
                                    scorePopups.push({ text: `+${earnedScore} (P${shooter.id})`, x: zombie.x, y: zombie.y, life: 60, vy: -0.5, color: shooter.color });
                                    shooter.score += earnedScore;
                                    zombies.splice(j, 1);
                                }
                            }
                        }
                        
                        scorePopups.push({ text: '', x: explosionCenter.x, y: explosionCenter.y, life: 10, radius: 1, maxRadius: RPG_BLAST_RADIUS, color: '#ff8800' });
                        bullets.splice(i, 1); 
                    } else if (hit && !bullet.isRpg) {
                        bullets.splice(i, 1); 
                    }
                }

                for (let i = healPacks.length - 1; i >= 0; i--) {
                    const pack = healPacks[i];
                    players.forEach(p => {
                        if (p.health > 0) {
                            const dx = pack.x - p.x;
                            const dy = pack.y - p.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < p.size / 2 + pack.size / 2) {
                                p.health = Math.min(p.maxHealth, p.health + HEAL_AMOUNT);
                                scorePopups.push({ text: `+${HEAL_AMOUNT} HEALTH`, x: p.x, y: p.y - 15, life: 60, vy: -0.5, color: '#00ff00' });
                                healPacks.splice(i, 1);
                            }
                        }
                    });
                }
                
                for (let i = rpgPacks.length - 1; i >= 0; i--) {
                    const pack = rpgPacks[i];
                    players.forEach(p => {
                        if (p.health > 0) {
                            const dx = pack.x - p.x;
                            const dy = pack.y - p.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < p.size / 2 + pack.size / 2) {
                                p.rpgAmmo += 5; 
                                p.weapon = WEAPONS.RPG;
                                scorePopups.push({ text: `RPG AMMO +5`, x: p.x, y: p.y - 15, life: 60, vy: -0.5, color: '#ff4500' });
                                rpgPacks.splice(i, 1);
                            }
                        }
                    });
                }

                zombieSpawnTimer++;
                if (zombiesRemainingToSpawn > 0 && zombies.length < 15 && zombieSpawnTimer >= ZOMBIE_SPAWN_INTERVAL) {
                    spawnZombie();
                    zombieSpawnTimer = 0;
                }
                
                healSpawnTimer++;
                if (healSpawnTimer >= HEAL_SPAWN_INTERVAL && healPacks.length < 3) { 
                    spawnHealPack(); 
                    healSpawnTimer = 0;
                }
                
                if (zombiesRemainingToSpawn === 0 && zombies.length === 0) {
                    startNewWave();
                }

                const alivePlayers = players.filter(p => p.health > 0).length;
                if (alivePlayers === 0) {
                    endGame();
                }
            }

            function render() {
                ctx.fillStyle = '#334';
                ctx.fillRect(0, 0, W, H);

                scorePopups.forEach(popup => {
                    if (popup.radius) {
                        const lifeRatio = popup.life / 10;
                        const radius = popup.maxRadius * (1 - lifeRatio);
                        ctx.fillStyle = `rgba(255, 136, 0, ${lifeRatio * 0.5})`; 
                        ctx.beginPath();
                        ctx.arc(popup.x, popup.y, radius, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                });

                players.forEach(p => {
                    if (p.health > 0 && p.hitFlashTimer > 0) {
                        ctx.fillStyle = `rgba(255, 0, 0, ${p.hitFlashTimer / HIT_FLASH_DURATION * 0.3})`;
                        ctx.fillRect(0, 0, W, H);
                    }
                });

                healPacks.forEach(drawHealPack);
                rpgPacks.forEach(drawRpgPack);

                bullets.forEach(bullet => {
                    drawBlock(bullet.x - bullet.radius, bullet.y - bullet.radius, bullet.radius * 2, bullet.radius * 2, bullet.color);
                });

                zombies.forEach(drawZombie);
                
                players.forEach(p => {
                    if (p.health > 0) {
                        drawPlayer(p);
                    }
                    if (p.health > 0 && p.hitFlashTimer > 0) {
                        const totalHeight = 8 + 8 + 6 + 2; 
                        ctx.fillStyle = `rgba(255, 0, 0, ${p.hitFlashTimer / HIT_FLASH_DURATION * 0.8})`;
                        ctx.fillRect(p.x - p.size, p.y - totalHeight / 2 - 2, p.size * 2, totalHeight + 4);
                    }
                });
                
                scorePopups.forEach(popup => {
                    if (popup.text) {
                        ctx.font = '8px "Press Start 2P"';
                        ctx.strokeStyle = '#000000'; 
                        ctx.lineWidth = 2;
                        ctx.fillStyle = popup.color || `rgba(255, 255, 0, ${popup.life / 60})`; 
                        const textWidth = ctx.measureText(popup.text).width;
                        const textX = popup.x - textWidth / 2;
                        ctx.strokeText(popup.text, textX, popup.y);
                        ctx.fillText(popup.text, textX, popup.y);
                    }
                });

                updateUI();
                
                if (isPaused) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                    ctx.fillRect(0, 0, W, H);
                }
            }

            function gameLoop(timestamp) {
                if (isGameOver || isPaused || isTicTacToeActive || gameContainer.classList.contains('hidden')) return;

                const deltaTime = (timestamp - lastUpdateTime) / 1000;
                lastUpdateTime = timestamp;

                handleInput();
                updateGame(deltaTime);
                render();

                animationFrameId = requestAnimationFrame(gameLoop);
            }

            // --- Event Handlers ---
            function handleMouseMove(e) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                mouse.x = (e.clientX - rect.left) * scaleX;
                mouse.y = (e.clientY - rect.top) * scaleY;
            }

            function handleMouseDown(e) {
                if (e.button === 0) {
                    mouse.clicked = true;
                }
            }

            function handleMouseUp(e) {
                if (e.button === 0) {
                    mouse.clicked = false;
                }
            }

            // Button Click Handlers for Modals
            select1PlayerButton.onclick = () => showDifficultyMenu(1);
            select2PlayersButton.onclick = () => showDifficultyMenu(2);
            resumeButton.onclick = togglePause;
            changeModeButton.onclick = showPlayerCountMenu;
            
            // Tic-Tac-Toe Button Handlers
            playTicTacToeButton.onclick = toggleTicTacToe;
            tttRestartButton.onclick = initTicTacToe;
            tttCloseButton.onclick = toggleTicTacToe;


            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mouseup', handleMouseUp);

            // --- Game Flow Control ---

            function initGame() {
                players = [];
                for (let i = 0; i < playerCount; i++) {
                    const template = JSON.parse(JSON.stringify(PLAYER_TEMPLATES[i])); 
                    template.health = currentDifficulty.playerHealth;
                    template.maxHealth = currentDifficulty.playerHealth;
                    template.weapon = WEAPONS.SHOTGUN; 
                    template.keys = {}; 
                    template.lastShotTime = 0; 
                    template.rpgAmmo = 0; 
                    players.push(template);
                }

                bullets = [];
                zombies = [];
                healPacks = []; 
                rpgPacks = [];
                scorePopups = []; 
                zombieSpawnTimer = 0;
                healSpawnTimer = 0; 
                isGameOver = false;
                isPaused = false; 
                isTicTacToeActive = false; 
                currentWave = 0;
                zombiesPerWave = 0;
                zombiesRemainingToSpawn = 0;

                hideAllModals();

                lastUpdateTime = performance.now();
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                }
                animationFrameId = requestAnimationFrame(gameLoop);
            }

            function endGame() {
                isGameOver = true;
                isPaused = true;
                isTicTacToeActive = false;
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null; 
                }

                wavesSurvivedDisplay.textContent = currentWave - 1; 
                finalScore1Display.textContent = String(players[0].score).padStart(5, '0');
                
                if (playerCount === 2) {
                    p2FinalScoreContainer.classList.remove('hidden');
                    finalScore2Display.textContent = String(players[1].score).padStart(5, '0');
                } else {
                    p2FinalScoreContainer.classList.add('hidden');
                }

                gameOverModal.classList.remove('hidden');
                gameOverModal.classList.add('flex');

                setTimeout(() => {
                    if (isGameOver) {
                         showPlayerCountMenu();
                    }
                }, 3000); 
            }

            // --- Initial Start (Starts on the Educational Cover) ---
            window.onload = function() {
                generateDifficultyButtons();
                // Ensure the calculator is functional immediately
                updateCalculatorDisplay();
            };
        })();
    </script>
</body>
</html>
