<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Dead: SNES Zombie Shooter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Use a retro-style font -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* Global retro/pixelated style */
        body {
            font-family: 'Press Start 2P', monospace;
            background-color: #1e1e2e; /* Dark, retro background */
            /* Full viewport centering for immersive feel */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 1rem;
        }

        /* Essential for true pixel scaling in modern browsers */
        canvas {
            image-rendering: optimizeSpeed; 
            image-rendering: -moz-crisp-edges; 
            image-rendering: -webkit-optimize-contrast; 
            image-rendering: crisp-edges;
            image-rendering: pixelated;
            border: 4px solid #f0f0f0; /* Light border for contrast */
            box-shadow: 0 0 0 8px #444455; /* Chunky outer shadow/bezel */
            background-color: #334; /* Dark game background */
            /* Responsive size adjustment */
            width: 100%; 
            max-width: 800px; /* Cap the max width to prevent excessive scaling */
            height: auto;
            aspect-ratio: 512 / 400; /* Maintain the fixed aspect ratio */
        }

        .game-ui-text {
            color: #f0f0f0;
            text-shadow: 2px 2px #000;
        }

        /* Modal styling */
        .modal {
            background: rgba(0, 0, 0, 0.85);
        }

        .modal-content {
            background: #222233;
            border: 4px solid #ffcc00;
            box-shadow: 0 0 10px #ffcc00;
        }
        
        .snes-button {
            padding: 12px 20px;
            font-size: 0.75rem; /* Small font for pixel style */
            text-shadow: 1px 1px #000;
            color: #f0f0f0;
            background-color: #444455;
            border: 3px solid #666677;
            border-bottom-width: 6px;
            transition: all 0.1s ease;
            box-shadow: 0 4px #222233;
            text-transform: uppercase;
        }

        .snes-button:hover {
            background-color: #555566;
        }

        .snes-button:active {
            border-bottom-width: 3px;
            transform: translateY(3px);
            box-shadow: 0 1px #222233;
        }

        /* Mobile Controls Styling (Touch) */
        .mobile-controls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            display: none;
            padding: 10px;
        }

        @media (max-width: 768px) {
            .mobile-controls {
                display: flex;
                justify-content: space-between;
                padding: 10px 20px;
            }
            .mobile-controls button {
                /* Simple style for mobile controls */
                width: 60px;
                height: 60px;
                background-color: #666;
                color: white;
                border: none;
                border-radius: 8px;
                font-size: 1.2rem;
                display: flex;
                justify-content: center;
                align-items: center;
                box-shadow: 0 3px 0 #444;
            }
            .mobile-controls button:active {
                 box-shadow: 0 0 0 #444;
                 transform: translateY(3px);
            }
        }
    </style>
</head>
<body>

    <!-- UI Display Bar -->
    <div id="uiContainer" class="flex justify-between w-full max-w-[800px] p-2 text-xs sm:text-sm game-ui-text">
        <span id="scoreDisplay">SCORE: 00000</span>
        <span id="weaponDisplay">WEAPON: Shotgun</span>
        <span id="healthDisplay">HEALTH: 100</span>
    </div>

    <canvas id="gameCanvas" width="512" height="400"></canvas>

    <!-- 1. Start Menu Modal -->
    <div id="startMenuModal" class="modal fixed inset-0 z-50 flex items-center justify-center">
        <div class="modal-content p-8 rounded-lg text-center game-ui-text w-11/12 max-w-md">
            <h1 class="text-xl sm:text-2xl mb-6 text-cyan-400">PIXEL DEAD</h1>
            <h2 class="text-lg sm:text-xl mb-6 text-white">SELECT DIFFICULTY</h2>
            <div id="difficultyButtons" class="flex flex-col space-y-4">
                <!-- Buttons will be generated by JS -->
            </div>
            <p class="text-xs mt-6 text-gray-400">Controls: WASD/Arrows to Move, Mouse Click to Shoot, Q to Swap Weapon, ESC to Pause</p>
        </div>
    </div>
    
    <!-- 2. Pause Menu Modal -->
    <div id="pauseModal" class="modal fixed inset-0 z-50 hidden items-center justify-center">
        <div class="modal-content p-8 rounded-lg text-center game-ui-text w-11/12 max-w-md">
            <h2 class="text-xl sm:text-2xl mb-6 text-yellow-400">GAME PAUSED</h2>
            <p id="currentModeDisplay" class="text-sm mb-6 text-white"></p>
            <div class="flex flex-col space-y-4">
                <button id="resumeButton" class="snes-button bg-green-600 border-green-700 hover:bg-green-700 active:bg-green-800">
                    Resume Game (ESC)
                </button>
                <button id="changeModeButton" class="snes-button bg-red-600 border-red-700 hover:bg-red-700 active:bg-red-800">
                    Change Difficulty / Exit
                </button>
            </div>
        </div>
    </div>


    <!-- 3. Game Over Modal (Used for auto-restart message) -->
    <div id="gameOverModal" class="modal fixed inset-0 z-50 hidden items-center justify-center">
        <div class="modal-content p-8 rounded-lg text-center game-ui-text w-11/12 max-w-md">
            <h2 class="text-xl sm:text-2xl mb-4 text-red-500">GAME OVER!</h2>
            <p class="text-lg mb-4">Final Score: <span id="finalScore">0</span></p>
            <p class="text-sm">RESTARTING IN 3 SECONDS...</p>
        </div>
    </div>

    <!-- Mobile Controls (Hidden on desktop) -->
    <div class="mobile-controls">
        <button id="moveLeft">◀</button>
        <button id="moveUp">▲</button>
        <button id="moveDown">▼</button>
        <button id="moveRight">▶</button>
    </div>


    <script>
        // Wrap the entire game logic in an IIFE to isolate scope and prevent global conflicts.
        (function() {
            // --- Game Constants and Setup ---
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const W = canvas.width;
            const H = canvas.height;

            // UI Elements
            const scoreDisplay = document.getElementById('scoreDisplay');
            const healthDisplay = document.getElementById('healthDisplay');
            const weaponDisplay = document.getElementById('weaponDisplay'); 
            const gameOverModal = document.getElementById('gameOverModal');
            const finalScoreDisplay = document.getElementById('finalScore');
            const startMenuModal = document.getElementById('startMenuModal');
            const difficultyButtonsContainer = document.getElementById('difficultyButtons');
            const pauseModal = document.getElementById('pauseModal');
            const currentModeDisplay = document.getElementById('currentModeDisplay');
            const resumeButton = document.getElementById('resumeButton');
            const changeModeButton = document.getElementById('changeModeButton');
            
            // Game State Flags and Variables
            let isGameOver = true;
            let isPaused = false; // New pause state
            let score = 0;
            let lastUpdateTime = 0;
            let animationFrameId;
            let currentDifficulty = null; // Stores the active difficulty settings
            
            // Damage feedback constants
            let hitFlashTimer = 0; 
            const HIT_FLASH_DURATION = 15; // 15 frames of screen flash AND invulnerability
            const MUZZLE_FLASH_DURATION = 50; 
            
            // --- DIFFICULTY PRESETS ---
            const DIFFICULTIES = {
                EASY: {
                    name: "Easy",
                    color: "text-green-400",
                    zombieSpeedMultiplier: 0.8,
                    zombieHealthMultiplier: 0.75,
                    spawnIntervalFrames: 180, // Slower spawn
                    playerHealth: 150, // More health
                    scoreMultiplier: 1.0,
                },
                MEDIUM: {
                    name: "Medium",
                    color: "text-yellow-400",
                    zombieSpeedMultiplier: 1.0,
                    zombieHealthMultiplier: 1.0,
                    spawnIntervalFrames: 120, // Standard spawn
                    playerHealth: 100, // Standard health
                    scoreMultiplier: 1.5,
                },
                HARD: {
                    name: "Hard",
                    color: "text-orange-400",
                    zombieSpeedMultiplier: 1.2,
                    zombieHealthMultiplier: 1.5,
                    spawnIntervalFrames: 80, // Fast spawn
                    playerHealth: 75,
                    scoreMultiplier: 2.0,
                },
                SUPER_HARD: {
                    name: "Super Hard",
                    color: "text-red-500",
                    zombieSpeedMultiplier: 1.5,
                    zombieHealthMultiplier: 2.0,
                    spawnIntervalFrames: 50, // Very fast spawn
                    playerHealth: 50,
                    scoreMultiplier: 3.0,
                }
            };
            
            // --- RPG Pack Constants ---
            const RPG_SPAWN_CHANCE = 0.02; // 2% chance to spawn an RPG pack per zombie spawn cycle
            const RPG_PACK_SIZE = 14;
            const RPG_MAX_ON_SCREEN = 1; // Only one RPG pack allowed at a time
            const RPG_BLAST_RADIUS = 60; // AOE size
            const RPG_DAMAGE = 15; // Base damage
            
            // --- Heal Pack Constants ---
            const HEAL_AMOUNT = 25; // Health restored
            const HEAL_SPAWN_INTERVAL = 300; // Frames (~5 seconds)

            // --- Zombie Type Configurations (Base Stats) ---
            const ZOMBIE_TYPES_BASE = {
                NORMAL: {
                    health: 3,
                    size: 12,
                    speedBase: 0.8,
                    score: 100,
                    color: '#00cc00', // Green
                    headColor: '#ff0000'
                },
                TANK: {
                    health: 10,
                    size: 20, // Larger size
                    speedBase: 0.5, // Slower speed
                    score: 500,
                    color: '#8b0000', // Dark Red
                    headColor: '#ffcc00'
                }
            };
            
            // --- Weapon Configurations ---
            const WEAPONS = {
                SHOTGUN: {
                    type: 'ranged',
                    fireRate: 350, // Time between shots in ms
                    bulletDamage: 1, // Damage per shot
                    bulletSpeed: 10,
                    name: "Shotgun"
                },
                KNIFE: {
                    type: 'melee',
                    fireRate: 500, // Time between swings in ms
                    damage: 2, // Damage per swing
                    range: 20, // Melee range in pixels
                    name: "Machete"
                },
                RPG: { // New weapon type
                    type: 'ranged_aoe',
                    fireRate: 1500, // Long cooldown
                    bulletDamage: RPG_DAMAGE, 
                    bulletSpeed: 5, // Slower projectile
                    name: "RPG (1)"
                }
            };

            // --- Game State Objects ---
            let player = {
                x: W / 2,
                y: H / 2,
                size: 16, // Base size for player
                speed: 4,
                health: 100, // Will be overridden by difficulty
                maxHealth: 100, // Will be overridden by difficulty
                color: '#00ffff', 
                pantsColor: '#4b4b4b', 
                isSwapping: false, 
                rpgAmmo: 0, 
            };

            let currentWeapon = WEAPONS.SHOTGUN; 

            let bullets = [];
            let zombies = [];
            let healPacks = []; 
            let rpgPacks = []; 
            let keys = {};
            let scorePopups = []; 
            
            let mouse = { x: 0, y: 0, clicked: false, canShoot: true, lastShotTime: 0 }; 
            let zombieSpawnTimer = 0;
            let healSpawnTimer = 0; 
            let ZOMBIE_SPAWN_INTERVAL = 120; // Will be overridden by difficulty

            // --- UI/Modal Logic ---
            function showStartMenu() {
                isGameOver = true;
                isPaused = true;
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                
                // Ensure all game modals are hidden
                gameOverModal.classList.add('hidden');
                pauseModal.classList.add('hidden');

                // Show start menu
                startMenuModal.classList.remove('hidden');
                startMenuModal.classList.add('flex');
            }

            function generateDifficultyButtons() {
                difficultyButtonsContainer.innerHTML = '';
                Object.keys(DIFFICULTIES).forEach(key => {
                    const diff = DIFFICULTIES[key];
                    const button = document.createElement('button');
                    button.className = `snes-button ${diff.color.replace('text-', 'bg-')}`; // Use difficulty color for button background
                    button.textContent = `${diff.name.toUpperCase()} (Health: ${diff.playerHealth} | Score Multiplier: ${diff.scoreMultiplier}x)`;
                    button.onclick = () => startGame(diff);
                    difficultyButtonsContainer.appendChild(button);
                });
            }
            
            function startGame(difficulty) {
                currentDifficulty = difficulty;
                player.maxHealth = difficulty.playerHealth;
                ZOMBIE_SPAWN_INTERVAL = difficulty.spawnIntervalFrames;

                startMenuModal.classList.add('hidden');
                startMenuModal.classList.remove('flex');
                
                initGame();
            }

            function togglePause() {
                if (isGameOver) return;

                isPaused = !isPaused;

                if (isPaused) {
                    // Show Pause Menu
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }
                    currentModeDisplay.textContent = `Current Mode: ${currentDifficulty.name.toUpperCase()}`;
                    pauseModal.classList.remove('hidden');
                    pauseModal.classList.add('flex');
                } else {
                    // Resume Game
                    pauseModal.classList.add('hidden');
                    pauseModal.classList.remove('flex');

                    // Restart loop
                    lastUpdateTime = performance.now();
                    animationFrameId = requestAnimationFrame(gameLoop);
                }
            }
            
            // --- Helper Functions (SNES Pixel Art Rendering) ---

            function drawBlock(x, y, w, h, color) {
                ctx.fillStyle = color;
                ctx.fillRect(Math.round(x), Math.round(y), w, h);
            }

            function drawHealPack(pack) {
                const s = pack.size;
                const x = pack.x;
                const y = pack.y;

                drawBlock(x - s/2, y - s/2, s, s, '#ff0000');
                
                const armLength = s * 0.6;
                const armThickness = s * 0.2;
                const offset = armThickness / 2;

                drawBlock(x - offset, y - armLength/2, armThickness, armLength, '#00ff00');
                drawBlock(x - armLength/2, y - offset, armLength, armThickness, '#00ff00');
            }

            function drawRPGPack(pack) {
                const s = pack.size;
                const x = pack.x;
                const y = pack.y;

                drawBlock(x - s/2, y - s/2, s, s, '#556b2f');
                
                drawBlock(x - s/4, y - s/2 + 2, s/2, s/4, '#ff4500'); 
                drawBlock(x - s/8, y - s/4, s/4, s/2, '#888888'); 
                
                ctx.font = '6px "Press Start 2P"';
                ctx.fillStyle = '#ffffff';
                ctx.fillText("RPG", x - 6, y + s/2 + 4); 
            }

            function drawPlayer() {
                const s = player.size; 
                const x = player.x;
                const y = player.y;
                const bodyColor = player.color; 
                const pantsColor = player.pantsColor; 
                const skinColor = '#ffdbac'; 

                const headSize = Math.max(4, Math.round(s * 0.4)); 
                const torsoWidth = Math.max(8, Math.round(s * 0.8)); 
                const torsoHeight = Math.round(s * 0.9); 
                const legWidth = Math.max(3, Math.round(s * 0.35));
                const legHeight = Math.round(s * 0.5);

                const totalHeight = headSize + torsoHeight + legHeight;
                let currentY = y - totalHeight / 2;
                
                drawBlock(x - headSize / 2, currentY, headSize, headSize, skinColor);
                currentY += headSize;

                const torsoY = currentY;
                drawBlock(x - torsoWidth / 2, torsoY, torsoWidth, torsoHeight, bodyColor);
                
                const bloodColor = '#cc0000';
                drawBlock(x - torsoWidth / 2 + 1, torsoY + 1, 2, 2, bloodColor);
                drawBlock(x + torsoWidth / 2 - 3, torsoY + 3, 2, 2, bloodColor);
                drawBlock(x - 1, torsoY + torsoHeight - 3, 3, 1, bloodColor);

                currentY += torsoHeight;
                
                const legGap = torsoWidth - (legWidth * 2);
                const gapHalf = Math.max(1, Math.round(legGap / 2));
                
                drawBlock(x - legWidth - gapHalf, currentY, legWidth, legHeight, pantsColor);
                drawBlock(x + gapHalf, currentY, legWidth, legHeight, pantsColor);
                
                const dx = mouse.x - x;
                const dy = mouse.y - y;
                const angle = Math.atan2(dy, dx);

                const armLength = s / 2 + 1;
                const gunPivotX = x + Math.cos(angle) * armLength;
                const gunPivotY = y + Math.sin(angle) * armLength;

                ctx.save();
                ctx.translate(gunPivotX, gunPivotY);
                ctx.rotate(angle);

                if (currentWeapon === WEAPONS.SHOTGUN || currentWeapon === WEAPONS.RPG) {
                    const barrelLength = currentWeapon === WEAPONS.RPG ? 16 : 12;
                    const barrelThickness = currentWeapon === WEAPONS.RPG ? 8 : 5;
                    const handleLength = 4;
                    const handleThickness = 3;

                    ctx.fillStyle = currentWeapon === WEAPONS.RPG ? '#4b4b4b' : '#666666';
                    ctx.fillRect(0, -barrelThickness / 2, barrelLength, barrelThickness);
                    
                    if (currentWeapon === WEAPONS.RPG) {
                        drawBlock(barrelLength - 3, -barrelThickness / 2, 3, barrelThickness, '#ff4500');
                    }

                    ctx.fillStyle = '#444444';
                    ctx.fillRect(-handleLength, -handleThickness / 2, handleLength, handleThickness);
                } else if (currentWeapon === WEAPONS.KNIFE) {
                    const bladeLength = 10;
                    const bladeWidth = 3;
                    const handleLength = 4;
                    const handleWidth = 2;

                    ctx.fillStyle = '#cccccc';
                    ctx.fillRect(0, -bladeWidth / 2, bladeLength, bladeWidth);

                    ctx.fillStyle = '#4a2c1b';
                    ctx.fillRect(-handleLength, -handleWidth / 2, handleLength, handleWidth);
                }
                
                ctx.restore();

                const barWidth = 24;
                const barHeight = 4;
                const barX = x - barWidth / 2;
                const barY = y - totalHeight / 2 - 6; 
                const healthRatio = player.health / player.maxHealth;
                const filledWidth = barWidth * healthRatio;

                drawBlock(barX - 1, barY - 1, barWidth + 2, barHeight + 2, '#000000'); 
                drawBlock(barX, barY, barWidth, barHeight, '#444444');

                if (filledWidth > 0) {
                    let healthColor = '#00ff00';
                    if (healthRatio < 0.5) healthColor = '#ffcc00';
                    if (healthRatio < 0.25) healthColor = '#ff0000';
                    drawBlock(barX, barY, filledWidth, barHeight, healthColor);
                }
            }

            function drawZombie(zombie) {
                const s = zombie.size; 
                const x = zombie.x;
                const y = zombie.y;
                const headColor = zombie.type.headColor;
                // Change body color based on health remaining
                const bodyColor = zombie.health > ZOMBIE_TYPES_BASE.NORMAL.health * currentDifficulty.zombieHealthMultiplier / 2 
                                  ? zombie.type.color 
                                  : '#cc0000'; 

                const headSize = Math.max(6, Math.round(s * 0.5)); 
                const torsoWidth = Math.max(8, Math.round(s * 0.7)); 
                const torsoHeight = Math.round(s * 0.8); 
                const legWidth = Math.max(3, Math.round(s * 0.3));
                const legHeight = Math.round(s * 0.5);
                const armWidth = Math.max(2, Math.round(s * 0.15));
                const armHeight = torsoHeight + 2; 

                const totalHeight = headSize + torsoHeight + legHeight;
                let currentY = y - totalHeight / 2;
                
                drawBlock(x - headSize / 2, currentY, headSize, headSize, headColor);
                currentY += headSize;

                const torsoY = currentY;
                drawBlock(x - torsoWidth / 2, torsoY, torsoWidth, torsoHeight, bodyColor);
                
                drawBlock(x - torsoWidth / 2 - armWidth, torsoY, armWidth, armHeight, bodyColor);
                drawBlock(x + torsoWidth / 2, torsoY, armWidth, armHeight, bodyColor);

                currentY += torsoHeight;
                
                const legGap = torsoWidth - (legWidth * 2);
                const gapHalf = Math.max(1, Math.round(legGap / 2));
                
                drawBlock(x - legWidth - gapHalf, currentY, legWidth, legHeight, bodyColor);
                drawBlock(x + gapHalf, currentY, legWidth, legHeight, bodyColor);
                
                const eyeSize = 1;
                const eyeOffset = headSize / 4;
                const eyeY = y - totalHeight/2 + headSize/3;
                drawBlock(x - eyeOffset - eyeSize/2, eyeY, eyeSize, eyeSize, '#000000'); 
                drawBlock(x + eyeOffset - eyeSize/2, eyeY, eyeSize, eyeSize, '#000000'); 
            }

            // --- Core Game Logic ---

            function updateUI() {
                scoreDisplay.textContent = `SCORE: ${String(score).padStart(5, '0')} (${currentDifficulty.scoreMultiplier}x)`;
                healthDisplay.textContent = `HEALTH: ${Math.max(0, player.health)}`; 
                
                let weaponName = currentWeapon.name;
                
                if (currentWeapon === WEAPONS.RPG) {
                    weaponName = `RPG (${player.rpgAmmo})`;
                } else if (currentWeapon === WEAPONS.SHOTGUN) {
                    weaponName = (player.rpgAmmo > 0) ? `Shotgun (Q: RPG)` : `Shotgun (Q: Machete)`;
                } else if (currentWeapon === WEAPONS.KNIFE) {
                    weaponName = (player.rpgAmmo > 0) ? `Machete (Q: RPG)` : `Machete (Q: Shotgun)`;
                }
                
                weaponDisplay.textContent = `WEAPON: ${weaponName}`;
            }

            function spawnZombie() {
                // Apply difficulty modifiers to base stats
                const diff = currentDifficulty;

                const typeKey = Math.random() < 0.2 ? 'TANK' : 'NORMAL';
                const baseType = ZOMBIE_TYPES_BASE[typeKey];
                
                const size = baseType.size;
                const speed = baseType.speedBase * diff.zombieSpeedMultiplier + score / 20000; 
                const health = Math.ceil(baseType.health * diff.zombieHealthMultiplier);
                
                let x, y;
                const side = Math.floor(Math.random() * 4);
                switch (side) {
                    case 0: x = Math.random() * W; y = -size; break; 
                    case 1: x = Math.random() * W; y = H + size; break;
                    case 2: x = -size; y = Math.random() * H; break;
                    case 3: x = W + size; y = Math.random() * H; break;
                }

                zombies.push({ 
                    x, 
                    y, 
                    size, 
                    speed, 
                    health, 
                    type: baseType 
                });
            }
            
            function spawnHealPack() {
                const size = 10; 
                const x = size / 2 + Math.random() * (W - size);
                const y = size / 2 + Math.random() * (H - size);
                
                healPacks.push({ x: x, y: y, size: size });
            }

            function spawnRPGPack() {
                const size = RPG_PACK_SIZE; 
                const x = size / 2 + Math.random() * (W - size);
                const y = size / 2 + Math.random() * (H - size);
                
                rpgPacks.push({ x: x, y: y, size: size });
            }

            function fireRangedWeapon(weapon) {
                const dx = mouse.x - player.x;
                const dy = mouse.y - player.y;
                const angle = Math.atan2(dy, dx);
                
                const isRpg = weapon.type === 'ranged_aoe';

                if (isRpg) {
                    if (player.rpgAmmo > 0) {
                        player.rpgAmmo--; 
                    } else {
                        currentWeapon = WEAPONS.SHOTGUN; 
                        return;
                    }
                }

                bullets.push({
                    x: player.x,
                    y: player.y,
                    vx: Math.cos(angle) * weapon.bulletSpeed,
                    vy: Math.sin(angle) * weapon.bulletSpeed,
                    radius: isRpg ? 6 : 3, 
                    color: isRpg ? '#ff4500' : '#ffff00', 
                    damage: weapon.bulletDamage,
                    isRpg: isRpg, 
                    blastRadius: isRpg ? RPG_BLAST_RADIUS : 0,
                });
                
                if (player.rpgAmmo === 0 && currentWeapon === WEAPONS.RPG) {
                    currentWeapon = WEAPONS.SHOTGUN;
                }
            }

            function performMeleeAttack(weapon) {
                for (let j = zombies.length - 1; j >= 0; j--) {
                    const zombie = zombies[j];
                    const dx = zombie.x - player.x;
                    const dy = zombie.y - player.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < player.size / 2 + weapon.range) {
                        zombie.health -= weapon.damage;
                        
                        if (zombie.health <= 0) {
                            const earnedScore = Math.floor(zombie.type.score * currentDifficulty.scoreMultiplier);
                            scorePopups.push({ text: `+${earnedScore}`, x: zombie.x, y: zombie.y, life: 60, vy: -0.5 });
                            score += earnedScore;
                            zombies.splice(j, 1);
                        }
                    }
                }
            }

            function handleAttack() {
                if (isGameOver || isPaused) return;
                
                const currentTime = Date.now();
                if (currentTime - mouse.lastShotTime < currentWeapon.fireRate) {
                    return; 
                }

                mouse.lastShotTime = currentTime; 

                if (currentWeapon.type === 'ranged' || currentWeapon.type === 'ranged_aoe') {
                    fireRangedWeapon(currentWeapon);
                } else if (currentWeapon.type === 'melee') {
                    performMeleeAttack(currentWeapon);
                }
            }


            function handleInput() {
                if (isGameOver || isPaused) return;

                if (keys['w'] || keys['ArrowUp'] || keys['arrowup']) player.y -= player.speed;
                if (keys['s'] || keys['ArrowDown'] || keys['arrowdown']) player.y += player.speed;
                if (keys['a'] || keys['ArrowLeft'] || keys['arrowleft']) player.x -= player.speed;
                if (keys['d'] || keys['ArrowRight'] || keys['arrowright']) player.x += player.speed;

                if (keys['q']) {
                    if (!player.isSwapping) {
                        player.isSwapping = true; 

                        if (currentWeapon === WEAPONS.SHOTGUN) {
                            currentWeapon = (player.rpgAmmo > 0) ? WEAPONS.RPG : WEAPONS.KNIFE;
                        } else if (currentWeapon === WEAPONS.KNIFE) {
                             currentWeapon = (player.rpgAmmo > 0) ? WEAPONS.RPG : WEAPONS.SHOTGUN;
                        } else if (currentWeapon === WEAPONS.RPG) {
                            currentWeapon = WEAPONS.SHOTGUN;
                        }
                    }
                } else {
                    player.isSwapping = false; 
                }
                
                if (currentWeapon === WEAPONS.RPG && player.rpgAmmo <= 0) {
                    currentWeapon = WEAPONS.SHOTGUN; 
                }

                player.x = Math.max(player.size / 2, Math.min(W - player.size / 2, player.x));
                player.y = Math.max(player.size / 2, Math.min(H - player.size / 2, player.y));

                if (mouse.clicked) {
                    handleAttack();
                }
            }

            function updateGame(deltaTime) {
                if (isPaused) return;

                if (hitFlashTimer > 0) {
                    hitFlashTimer--;
                }

                scorePopups = scorePopups.filter(popup => {
                    if (popup.vy) {
                        popup.y += popup.vy; 
                    }
                    popup.life--;
                    return popup.life > 0;
                });
                
                // 2. Update Bullets
                bullets = bullets.filter(bullet => {
                    bullet.x += bullet.vx;
                    bullet.y += bullet.vy;
                    return bullet.x > -W && bullet.x < W * 2 && bullet.y > -H && bullet.y < H * 2;
                });

                // 3. Update Zombies
                zombies.forEach(zombie => {
                    const dx = player.x - zombie.x;
                    const dy = player.y - zombie.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    zombie.x += (dx / dist) * zombie.speed;
                    zombie.y += (dy / dist) * zombie.speed;

                    if (dist < player.size / 2 + zombie.size / 2) {
                        if (hitFlashTimer <= 0) { 
                            if (player.health > 0) {
                                player.health -= 5; 
                                hitFlashTimer = HIT_FLASH_DURATION; 
                            }
                            player.x -= (dx / dist) * 5; 
                            player.y -= (dy / dist) * 5;
                        }
                    }
                });

                // 4. Collision Detection (Bullet vs Zombie)
                for (let i = bullets.length - 1; i >= 0; i--) {
                    const bullet = bullets[i];
                    let hit = false;
                    let explosionCenter = null; 

                    for (let j = zombies.length - 1; j >= 0; j--) {
                        const zombie = zombies[j];
                        const dx = bullet.x - zombie.x;
                        const dy = bullet.y - zombie.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < zombie.size / 2 + bullet.radius) {
                            zombie.health -= bullet.damage; 
                            hit = true;
                            explosionCenter = { x: bullet.x, y: bullet.y }; 
                            
                            if (!bullet.isRpg) { 
                                 if (zombie.health <= 0) {
                                     const earnedScore = Math.floor(zombie.type.score * currentDifficulty.scoreMultiplier);
                                     scorePopups.push({ text: `+${earnedScore}`, x: zombie.x, y: zombie.y, life: 60, vy: -0.5 });
                                     zombies.splice(j, 1);
                                     score += earnedScore; 
                                 }
                                break; 
                            } 
                        }
                    }

                    const offScreen = bullet.x < -10 || bullet.x > W + 10 || bullet.y < -10 || bullet.y > H + 10;
                    
                    if (bullet.isRpg && (hit || offScreen)) {
                        explosionCenter = explosionCenter || { x: bullet.x, y: bullet.y };
                        
                        for (let j = zombies.length - 1; j >= 0; j--) {
                            const zombie = zombies[j];
                            const dx = explosionCenter.x - zombie.x;
                            const dy = explosionCenter.y - zombie.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);

                            if (dist < bullet.blastRadius) {
                                const proximity = 1 - (dist / bullet.blastRadius); 
                                const aoeDamage = Math.ceil(bullet.damage * proximity);
                                zombie.health -= aoeDamage;
                                
                                zombie.x -= (dx / dist) * 10 * proximity; 
                                zombie.y -= (dy / dist) * 10 * proximity;

                                if (zombie.health <= 0) {
                                    const earnedScore = Math.floor(zombie.type.score * currentDifficulty.scoreMultiplier);
                                    scorePopups.push({ text: `+${earnedScore}`, x: zombie.x, y: zombie.y, life: 60, vy: -0.5 });
                                    zombies.splice(j, 1);
                                    score += earnedScore;
                                }
                            }
                        }
                        
                        scorePopups.push({
                            text: '', 
                            x: explosionCenter.x,
                            y: explosionCenter.y,
                            life: 10, 
                            radius: 1, 
                            maxRadius: RPG_BLAST_RADIUS,
                            color: '#ff8800' 
                        });

                        bullets.splice(i, 1); 
                    } else if (hit && !bullet.isRpg) {
                        bullets.splice(i, 1); 
                    }
                }

                // 5. Pickups
                for (let i = rpgPacks.length - 1; i >= 0; i--) {
                    const pack = rpgPacks[i];
                    const dx = player.x - pack.x;
                    const dy = player.y - pack.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < player.size / 2 + pack.size / 2) {
                        player.rpgAmmo += 1; 
                        scorePopups.push({ text: `+1 RPG`, x: pack.x, y: pack.y, life: 60, vy: -0.8, color: '#ffcc00' });
                        if (player.rpgAmmo === 1 && currentWeapon !== WEAPONS.RPG) {
                            currentWeapon = WEAPONS.RPG;
                        }
                        rpgPacks.splice(i, 1);
                    }
                }
                
                for (let i = healPacks.length - 1; i >= 0; i--) {
                    const pack = healPacks[i];
                    const dx = player.x - pack.x;
                    const dy = player.y - pack.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < player.size / 2 + pack.size / 2) {
                        const oldHealth = player.health;
                        player.health = Math.min(player.maxHealth, player.health + HEAL_AMOUNT);
                        const healedAmount = player.health - oldHealth;

                        if (healedAmount > 0) {
                            scorePopups.push({ text: `+${healedAmount} HP`, x: pack.x, y: pack.y, life: 60, vy: -0.8, color: '#00ff00' });
                        }
                        healPacks.splice(i, 1);
                    }
                }

                // 6. Spawning
                zombieSpawnTimer++;
                if (zombieSpawnTimer >= ZOMBIE_SPAWN_INTERVAL) {
                    spawnZombie();
                    zombieSpawnTimer = 0;
                    
                    if (rpgPacks.length < RPG_MAX_ON_SCREEN && Math.random() < RPG_SPAWN_CHANCE) {
                        spawnRPGPack();
                    }
                }
                
                healSpawnTimer++;
                if (healSpawnTimer >= HEAL_SPAWN_INTERVAL && healPacks.length < 3) { 
                    spawnHealPack();
                    healSpawnTimer = 0;
                }

                // 7. Check Game Over
                if (player.health <= 0) {
                    endGame();
                }
            }

            function render() {
                // Clear screen (Dark Street Background)
                ctx.fillStyle = '#334';
                ctx.fillRect(0, 0, W, H);

                // --- DAMAGE FLASH EFFECT ---
                if (hitFlashTimer > 0) {
                    ctx.fillStyle = `rgba(255, 0, 0, ${hitFlashTimer / HIT_FLASH_DURATION * 0.3})`;
                    ctx.fillRect(0, 0, W, H);
                }

                // Draw Bullets
                bullets.forEach(bullet => {
                    drawBlock(bullet.x - bullet.radius, bullet.y - bullet.radius, bullet.radius * 2, bullet.radius * 2, bullet.color);
                });

                // Draw Zombies
                zombies.forEach(drawZombie);
                
                // Draw Heal Packs
                healPacks.forEach(drawHealPack);
                
                // Draw RPG Packs
                rpgPacks.forEach(drawRPGPack);

                // Draw Player
                drawPlayer();
                
                // --- MUZZLE FLASH EFFECT ---
                if (currentWeapon === WEAPONS.SHOTGUN || currentWeapon === WEAPONS.RPG) {
                    const currentTime = Date.now();
                    const isRpg = currentWeapon === WEAPONS.RPG;
                    
                    if (currentTime - mouse.lastShotTime < MUZZLE_FLASH_DURATION) {
                        const dx = mouse.x - player.x;
                        const dy = mouse.y - player.y;
                        const angle = Math.atan2(dy, dy);
                        
                        const flashDistance = isRpg ? player.size / 2 + 20 : player.size / 2 + 14; 

                        const flashX = player.x + Math.cos(angle) * flashDistance;
                        const flashY = player.y + Math.sin(angle) * flashDistance;

                        const flashColor = isRpg ? '#ffa500' : '#ffcc00';
                        drawBlock(flashX - 4, flashY - 4, 8, 8, flashColor);
                        drawBlock(flashX - 2, flashY - 2, 4, 4, '#ffffff'); 
                    }
                }

                // --- SCORE POPUPS and EFFECTS ---
                scorePopups.forEach(popup => {
                    if (popup.maxRadius) {
                        const timeRatio = popup.life / 10;
                        const currentRadius = popup.maxRadius * (1 - timeRatio); 
                        
                        ctx.fillStyle = `rgba(255, 136, 0, ${timeRatio})`;
                        ctx.beginPath();
                        ctx.arc(popup.x, popup.y, currentRadius, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = `rgba(255, 255, 0, ${timeRatio / 2})`;
                        ctx.beginPath();
                        ctx.arc(popup.x, popup.y, currentRadius * 0.5, 0, Math.PI * 2);
                        ctx.fill();

                    } else {
                        ctx.font = '8px "Press Start 2P"';
                        ctx.strokeStyle = '#000000'; 
                        ctx.lineWidth = 2;

                        ctx.fillStyle = popup.color || `rgba(255, 255, 0, ${popup.life / 60})`; 
                        
                        const textWidth = ctx.measureText(popup.text).width;
                        const textX = popup.x - textWidth / 2;

                        ctx.strokeText(popup.text, textX, popup.y);
                        ctx.fillText(popup.text, textX, popup.y);
                    }
                });

                // Update UI text
                updateUI();
                
                // Darken canvas slightly if paused, without hiding the pause modal
                if (isPaused) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                    ctx.fillRect(0, 0, W, H);
                }
            }

            function gameLoop(timestamp) {
                if (isGameOver || isPaused) return;

                const deltaTime = (timestamp - lastUpdateTime) / 1000;
                lastUpdateTime = timestamp;

                handleInput();
                updateGame(deltaTime);
                render();

                animationFrameId = requestAnimationFrame(gameLoop);
            }

            // --- Event Handlers ---

            function handleMouseMove(e) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                mouse.x = (e.clientX - rect.left) * scaleX;
                mouse.y = (e.clientY - rect.top) * scaleY;
            }

            function handleMouseDown(e) {
                if (e.button === 0) {
                    mouse.clicked = true;
                }
            }

            function handleMouseUp(e) {
                if (e.button === 0) {
                    mouse.clicked = false;
                }
            }

            function handleTouchMove(e) {
                e.preventDefault(); 
                if (e.touches.length > 0) {
                    const touch = e.touches[0];
                    handleMouseMove(touch);
                }
            }

            function handleTouchStart(e) {
                e.preventDefault();
                mouse.clicked = true;
                if (e.touches.length > 0) {
                    const touch = e.touches[0];
                    handleMouseMove(touch);
                }
            }

            function handleTouchEnd(e) {
                mouse.clicked = false;
            }

            document.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                keys[key] = true;
                
                if (key === 'escape') {
                    e.preventDefault();
                    if (!isGameOver) {
                        togglePause();
                    }
                }
                
                if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' ', 'q'].includes(key)) {
                    e.preventDefault();
                }
            });
            document.addEventListener('keyup', (e) => {
                const key = e.key.toLowerCase();
                keys[key] = false;
            });

            // Button Click Handlers for Modals
            resumeButton.onclick = togglePause;
            changeModeButton.onclick = showStartMenu;

            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd);


            function setupMobileControls() {
                const controls = [
                    { id: 'moveUp', keys: ['w', 'arrowup'] }, 
                    { id: 'moveDown', keys: ['s', 'arrowdown'] },
                    { id: 'moveLeft', keys: ['a', 'arrowleft'] },
                    { id: 'moveRight', keys: ['d', 'arrowright'] }
                ];

                controls.forEach(control => {
                    const btn = document.getElementById(control.id);
                    if (btn) {
                        const startEvent = (e) => {
                            e.preventDefault();
                            if (isPaused || isGameOver) return;
                            control.keys.forEach(key => {
                                keys[key] = true;
                            });
                        };
                        const endEvent = (e) => {
                            e.preventDefault();
                            control.keys.forEach(key => {
                                keys[key] = false;
                            });
                        };

                        btn.addEventListener('touchstart', startEvent, { passive: false });
                        btn.addEventListener('touchend', endEvent);
                        btn.addEventListener('mousedown', startEvent);
                        btn.addEventListener('mouseup', endEvent);
                    }
                });
            }
            setupMobileControls();

            // --- Game Flow Control ---

            function initGame() {
                // This is the reset/setup that runs ONLY after a mode is selected
                player.x = W / 2;
                player.y = H / 2;
                player.health = player.maxHealth; // Set by difficulty
                player.isSwapping = false; 
                player.rpgAmmo = 0; 
                currentWeapon = WEAPONS.SHOTGUN; 
                score = 0;
                bullets = [];
                zombies = [];
                healPacks = []; 
                rpgPacks = []; 
                keys = {};
                scorePopups = []; 
                hitFlashTimer = 0; 
                zombieSpawnTimer = 0;
                healSpawnTimer = 0; 
                isGameOver = false;
                isPaused = false; // Start unpaused

                // Ensure all menus are hidden
                gameOverModal.classList.add('hidden');
                pauseModal.classList.add('hidden');
                startMenuModal.classList.add('hidden');

                // Start loop
                lastUpdateTime = performance.now();
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                }
                animationFrameId = requestAnimationFrame(gameLoop);
            }

            function endGame() {
                isGameOver = true;
                isPaused = true; // Effectively paused until restart
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null; 
                }

                finalScoreDisplay.textContent = String(score).padStart(5, '0');
                gameOverModal.classList.remove('hidden');
                gameOverModal.classList.add('flex');

                // Auto-restart after 3 seconds
                setTimeout(() => {
                    if (isGameOver) { // Only auto-restart if player hasn't manually clicked 'Change Mode'
                         showStartMenu();
                    }
                }, 3000); 
            }

            // --- Initial Start ---
            window.onload = function() {
                generateDifficultyButtons();
                showStartMenu();
            };
        })(); // End of IIFE

    </script>
</body>
</html>
